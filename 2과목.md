# ‍🏄‍♂️ 정보처리기사 자격증 

# 🐳 2과목 : 소프트웨어 개발

## 📚 1장 : 데이터 입,출력 구현

### 👏 034 자료 구조

#### 1.  자료구조의 정의 

> - 일련의 자료들을 조직하고 구조화하는 것
> - 필요한 모든 연산들을 처리할 수 있다. 
> - 자료 구조에 따라 프로그램 실행시간이 달라진다. 

#### 2. 자료 구조의 분류 

- 선형구조(순서O)
> - 배열 
> - 선형리스트(연속리스트, 연결리스트)
> - 스택
> - 큐
> - 데크

- 비선형구조(순서X)
> - 트리

#### 3. 배열
> - 동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합이다. 
> - 첨자를 이용하여 데이터에 접근
> - 반복적인 데이터 처리에 적합한 구조
> -  데이터마다 동일한 이름의 변수를 사용해 처리가 간편
> - 사용한 첨자의 개수에 따라 n차원 배열이라고 부름

#### 4. 선형 리스트 
- 연속 리스트 
> - 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다. 
> - 기억장소 이용 효율이 가장 좋다. 
> - 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입 삭제 시 자료의 이동이 필요하다.(단점)
- 연결 리스트
> - 노드의 포인터 부분을 이용하여 서로 연결시킨 자료구조 
> - 노드의 삽입, 삭제 작업이 용이
> - 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다. 
> - 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다. 
> - 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다. 

#### 5. 스택
> - 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조
> - 후입선출 방식
> - 기억 공간이 꽉 채워져 있으면 오버플로가 발생, 삭제할 데이터가 없으면 언더플로 발생

#### 6. 큐
> - 한쪽에서는 삽입 작업이, 한쪽에서는 삭제 작업이 이뤄지는 자료구조
> - 선입선출 방식
> - 프런트 포인터 : 삭제 
> - 리어 포인터 : 삽입

#### 7. 트리 
- 트리 관련 용어

> - 노드 : 트리의 기본 요소  // ABCDEFGHIJKLM
> - 근 노드 : 트리의 맨 위에 있는 노드 // A
> - 디그리 : 각 노드에서 뻗어 나온 가지의 수 // A = 3
> - 단말 노드 = 잎 노드 : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드 // KLM
> - 자식 노드 : 어떤 노드에 연결된 다음 레벨의 노드들
> - 부모 노드 
> - 형제 노드 : 동일한 부모를 갖는 노드 
> - 트리의 디그리 : 노드들의 디그리 중 가장 많은 수 // 3  


### 👏 035 데이터저장소/데이터베이스/DBMS

#### 1. 데이터 저장소 
- 데이터저장소는 논리데이터저장소와 물리 데이터저장소로 구분
> - 논리 데이터저장소는 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것을 의미
> - 물리 데이터저장소는 소프트웨어가 운용될 환경의 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장한 것을 의미 

#### 2. DBMS
- DBMS : 데이터베이스를 관리해주는 소프트웨어
> - 정의 기능 : 정의, 이용 방식, 제약 조건 등을 명시하는 기능
> - 조작 기능 : 데이터 검색, 갱신, 삽입, 삭제 
> - 제어 기능 : 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안을 유지하고 권한을 검사할 수 있어야 한다. 여러 사용자가 데이터베이스를 동시에 접근할 때도 정확성을 유지하도록 **병행 제어**를 할 수 있어야 함

#### 3. DBMS의 장단점
- 장점
> - 데이터의 논리적, 물리적 독립성이 보장됨
> - 데이터의 중복을 피할 수 있어 기억 공간이 절약됨
> - 자료를 공동으로 이용할 수 있음
> - 데이터의 일관성 유지
> - 데이터의 무결성 유지 
> - 보안 유지 가능
> - 데이터의 표준화
> - 데이터를 통합하여 관리
> - 항상 최신 데이터 유지가능
> - 데이터의 실시간 처리 가능
- 단점 
> - 전문가가 부족
> - 전산화 비용 증가
> - 대용량이라 과부화 발생
> - 백업과 리커버리가 어려움
> - 시스템이 복잡 


### 👏 036. 데이터 입,출력 

#### 1. 데이터 입출력의 개요 

- 데이터 입출력은 데이터를 조작하는 모든 행위를 의미, 이와 같은 작업을 위해 SQL을 사용
- 데이터 접속 : 객체와 데이터를 연결하는 것
- 트랜잭션 : 수행되어야 할 인련의 연산들

#### 2. SQL 

- 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분됨

> - 데이터 정의어(DDL) : 정의, 변경, 삭제할 때 사용하는 언어
> - 데이터 조작어(DML) : 데이터를 실질적으로 처리하는 데 사용
> - 데이터 제어어(DCL) : 보안, 무결성, 회복, 병행, 수행제어 등을 정의할 때 사용

#### 3. 데이터 접속

- SQL Mapping : 프로그래밍 코드 내에 SQL을 직접 입력
- ORM : 객체지향 프로그래밍의 객체와 관계 데이터베이스의 데이터를 연결

#### 4. 트랜잭션 
- 논리적 기능들을 수행하기 위한 일련의 연산들을 의미
> - COMMIT : 데이터베이스에 반영하는 명령어
> - ROLLBACK : 이전 상태로 되돌리는 연산 
> - SAVEPOINT : 저장점을 지정하는 명령어 
### 👏 037. 절차형 SQL 

#### 1. 절차형 SQL이란?

- 절차형 SQL은 연속적인 실행이나 반복 등의 제어가 가능한 SQL을 의미한다. 
> - 연속적인 작업들을 처리하는데 적합하다. 
> - BEGIN ~ END 형식으로 작성되는 블록 구조
> - 절차형 SQL의 종류
>   (1) 프로시저 : 미리 저장해 놓은 SQL 작업을 수행한다. 
>   (2) 트리거 : 데이터의 입력, 갱신, 삭제 등 이벤트가 발생할 때마다 작업이 자동수행됨
    (3) 사용자 정의 함수 :  종료 시 예약어 Return을 사용하여 처리 결과를 단일값으로 반환

#### 2. 절차형 SQL의 테스트와 디버깅
> - 절차형 SQL은 테스트 전에 구문 오류나 참조오류의 존재 여부를 확인한다.
> - SHOW 명령어를 통해 내용을 확인하고 문제를 수정한다. 
> - 디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인한다.  

#### 3. 쿼리 성능 최적화
- 쿼리 성능 최적화는 SQL코드를 최적화하는 것이다. 

> - APM을 사용하여 최적화 할 쿼리를 선정해야 한다. 
> - 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토한다. 

## 📚 2장 : 통합 구현 

### 👏 038. 단위 모듈 구현 

#### 1. 단위 모듈이란? 
- 단위 모듈은 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다. 
- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다. 
- 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현할 수 있다. 
- 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있다. 

#### 2. 단위 기능 명세서 작성
- 단위 기능 명세서는 기능 및 코드 명세서나 설계 지침과 같이 단위 기능을 명세화한 문서들을 의미함. 
- 추상화 작업이 필요하다. 
- 구조화 과정을 거친다. 
- 정보 은닉(다른 모듈이 접근하거나 변경하지 못하도록 하는 것)의 원리를 고려한다. 

#### 3. 입출력 기능 구현 
- 입출력 기능을 위한 알고리즘 및 데이터를 구현한다. 
- CLI(키보드를 통해 명령어 입력 받음), GUI(MS의 아이콘 같은 거) 와의 연동을 고려함 
- 오픈소스 API를 이용하면 간편하게 구현 가능 

#### 4. 알고리즘 구현
- 디바이스 드라이버 모듈 : 하드웨어 주변 장치의 동작을 구현한 모듈 
- 네트워크 모듈 : 데이터 통신을 위한 기능
- 파일 모듈 : 컴퓨터 내부 데이터에 접근하는 방법을 구현한 모듈
- 메모리 모듈 : 통신 기능을 구현한 모듈 
- 프로세스 모듈 : 하나의 프로세스 안에서 다른 프로세서를 생성하는 방법을 구현한 모듈

#### . IPC
- IPC는 모듈 간 통신 방식을 구현하기  위해 사용되는  대표적인 프로그래밍 인터페이스 집합이다. 
- 프로세스 간 통신까지 구현이 가능합니다. 
- 종류 
    > - Shared Memory
    > - Socket
    > - Semaphores
    > - Pipes&named Pipes
    > - Message Queueing


### 👏 039. 단위 모듈 테스트 
#### 1. 단위 모듈 테스트의 개요 
- 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것
- 화이트박스 테스트(모든 논리적인 경로를 테스트) / 블랙박스 테스트 기법을(특정기능이 작동되나 테스트) 사용 
- 모듈 통합 후엔 오랜 시간 추적해야하지만 단위 모듈 테스트를 수행하면 쉽게 발견하고 수정할 수 있다.
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다. 

#### 2. 테스트 케이스 

- 단위 모듈은 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스를 만든다. 
- 표준에 따른 테스트 케이스의 구성요소는 다음과 같다.

    > - 식별자 
    > - 테스트 항목
    > - 입력 명세
    > - 출력 명세
    > - 환경 설정
    > - 특수 절차 요구
    > - 의존성 기술

#### 3. 테스트 프로세스 
- 테스트 프로세스 5단계

> **1. 계획 및 제어 단계** 
> **2. 분석 및 설계 단계** : 테스트 시나리오와 테스트 케이스를 작성
> **3. 구현 및 실현 단계** : 테스트 프로시저에 명세하는 단계, 단위 테스트 도구를 이용하여 테스트를 수행
> **4. 평가 단계** : 평가, 기록
> **5. 완료 단계** : 수행 과정과 산출물을 기록 및 저장하는 단계 


### 👏 040. 개발 지원 도구 

#### 1. 통합 개발 환경 
- 통합 개발 환경 도구는 코드의 자동 생성 및 컴파일이 가능하다. 
- 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이
- 외부의 다양한 서비스와 연동하여 개발에 편의를 제공한다. 
- 이클립스, 비주얼 스튜디오, 엑스코드, 안드로이드 스튜디오, IDEA

#### 2. 빌드 도구
- 빌드 도구는 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어를 말한다. 
- 대표적인 도구 : **Ant, Maven, Gradle** 
> **1. Ant** 
>       - 자바의 공식적인 빌드 도구 
>       - XML 기반 
>       - 정해진 규칙이나 표준 없이 스크립트의 재사용 어려움
> **2. Maven** 
>       - 아파치 소프트웨어 재단에서 개발됨  
>       - 규칙이나 표준이 존재하여 예외 사항만 기록하면 됨
>       - 컴파일과 빌드를 동시에 수행할 수 있다. 
>       - 의존성을 설정하여 라이브러리를 관리함
> **3. Gradle** 
>       - 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구이다. 
>       - 안드로이드 스튜디오의 공식 빌드 도구
>       - Maven과 동일하게 의존성을 활용, 그루비 기반의 빌드 스크립트를 사용

#### 3. 기타 협업 도구

- 프로젝트 및 일정 관리 : 구글 캘린더, 지라, 플로우
- 정보 공유 및 커뮤니케이션 : 슬랙, 잔디, 태스트월드
- 디자인 : 스케치, 제플린
- 기타 : 에버노트, 스웨거, 깃허브 

## 📚 3장 : 제품 소프트웨어 패키징 

### 👏 041. 소프트웨어 패키징 

#### 1. 소프트웨어 패키징이란?
- 소프트웨어 패키징이란 배포용 설치파일을 만드는 것이다.
> - 개발자가 아닌 사용자 중심으로 진행
> - 소스 코드는 향후 관리를 위해 모듈화 하여 패키징한다.
> - 다양한 환겨에서 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징
> - 사용자의 편의성 및 실행 환경을 우선적으로 고려

#### 2. 패키징 시 고려사항
>- 사용자의 시스템 환경, 운영체제 등 필요한 최소환경을 정의한다. 
>- UI는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 메뉴얼과 일치시켜 패키징한다.
>- 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
>- 안정적인 배표가 중요
>- 패키징의 변경 및 개선에 대한 관리를 항상 고려
#### 3. 패키징 작업 순서(기모빌 사적 변배)
> 1. 기능 식별 : 작성된 코드의 기능을 확인
> 2. 모듈화 : 코드들을 분류
> 3. 빌드 진행 : 모듈 단위별로 실행 파일을 만든다. 
> 4. 사용자 환경 분석 : 사용될 환경이나 최소 운영 환경을 정의한다. 
> 5. 패키징 및 적용 시험 : 배포용 파일 형식으로 패키징한다. 
> 6. 패키징 변경 개선 : 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선을 진행 
> 7. 배포 : 배포 수행 시 오류가 발생하면 해당 개발자에겍 전달하여 수정을 요청 

### 👏 042. 릴리즈 노트 작성 

#### 1. 릴리즈 노트란?

- 릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서다. 
>- 릴리즈 노트를 통해 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인 가능함 
>- 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있다. 
>- 릴리즈 노트는 소프트웨어의 초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공한다. 

#### 2. 릴리즈 노트 "초기" 버전 작성 시 고려사항 
- 릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 **현재 시제로 작성**해야한다. 
- 신규 소스, 빌드 등의 이력이 정확하게 관리되어 **변경 또는 개선된 항목에 대한 이력 정보들도 작성**되어야 한다. 
- 일반적으로 포함되는 항목 

> - **머릿말** : 릴리즈 노트 이름, 소프트웨어 이름, 버전, 날짜 등 
> - **개요** : 변경사항 전체에 대한 간략한 내용 
> - **목적** : 해당 릴리즈 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적
> - **문제 요약** : 수정된 버그에 대한 간략한 설명, 릴리즈 추가 항목에 대한 요약 
> - **재현 항목** : 버그 발견에 대한 과정 설명
> - **수정/개선 내용** : 수정/개선한 내용
> - **사용자 영향도** : 해당 릴리즈 버전에서의 기능 변화가 미 칠수 있는 영향에 대한 설명
> - **SW 지원 영향도** : 해당 릴리즈 버전에서의 기능 변화가 다른 프로그램에 미칠 수 있는 영향
> - **노트** : SW/HW 설치 항목, 업그레이드에 대한 참고 항목
> - **면책 조항** : 회사 및 스포트웨어와 관련하여 참조할 사항 
> - **연락처**

#### 3. 릴리즈 노트 "추가" 버전 작성 시 고려사항

- 소프트웨어의 테스트 과정에서 배타 버전이 출시되거나 긴급한 버그 수정, 업그레이드, 사용자 요청 등의 특수한 상황이 발생하는 경우 릴리즈 노트를 추가로 작성한다. 
> **1. 중대한 오류가 발생하여 긴급 수정하는 경우** : 릴리즈 버전 출시하고 버그 번호를 포함한 모든 수정된 내용을 다아 릴리즈 노트를 작성한다.
> **2. 소프트웨어에 대한 기능 업그레이드를 완료한 경우** : 릴리즈 버전을 출시하고 릴리즈 노트를 작성한다.   
> **3. 사용자로부터 접수된 요구사항에 의해 추가나 수정된 경우** : 자체 기능 향상과는 다른 별도의 릴리즈 버전으로 출시하고 릴리즈 노트를 작성한다. 

#### 4. 릴리즈 노트 작성 순서 
> **1. 모듈 식별** : 작성될 내용들을 확인한다. 
> **2. 릴리즈 정보 확인** : 릴리즈 노트 이름. 날짜 등을 정리한다. 
> **3. 릴리즈 노트 개요 작성** : 소프트웨어 및 변경사항 전체에 대한 간략한 내용을 작성
> **4. 영향도 체크**  : 릴리즈 버전에서의 변화가 다른 소프트웨어나 기능에 미칠 수 있는 영향 기술
> **5. 정식 릴리즈 노트 작성** : 정식 릴리즈 노트에 작성될 기본 사항들을 작성
> **6. 추가 개선 항목 식별** : 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트를 작성


### 👏 043 디지털 저작권 관리(DRM)

#### 1. 디지털 저작권 관리란? 
- 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 관리,보호하는 기술
> - 원본 콘텐츠가 아날로그인 경우 디지털로 변환 후 DRM 패키징 수행
> - 콘텐츠의 크기에 따라 
>          **(1) 크기가 작은 경우** : 실시간으로 패키징 수행
>          **(2) 크기가 큰 경우** : 미리 패키징 수행 후 배포
> - 사람에 따라 
>           **(1) 저작권자** : 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스에 등록된다.
>           **(2) 사용자** : 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인 받아야 한다.

#### 2. 디지털 저작권 관리의 흐름도(P.200)
- **클리어링 하우스** : 저작권에 대한 사용권한, 라이선스 발급, 사용량에 따른 결제관리 등을 수행
- **콘텐츠 제공자** : 콘텐츠를 제공하는 저작권자
  - **패키저** : 콘텐츠 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- **콘텐츠 분배자** : 암호화된 콘텐츠를 유통하는 곳
- **콘텐츠 소비자** : 구매해서 사용하는 주체
  - **DRM 컨트롤러** : 배포된 콘텐츠의 이용권한을 통제
  - **보안 컨테이너** : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치 

#### 4. 디지털 저작권 관리의 기술 요소
- 사용되는 기술 
> - 암호화
> - 키관리
> - 암호화 파일 생성
> - 식별 기술
> - 저작권 표현
> - 정책 관리
> - 크랙 방지 : 무단으로 사용하게 하는 기술이나 도구를 방지
> - 인증 

### 👏 044 소프트웨어 설치 매뉴얼 작성

#### 1. 소프트웨어 설치 메뉴얼이란? 
- 소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서이다. 

> - 사용자를 기준으로 작성
> - 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명
> - 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명 
> - 소프트웨어 설치 메뉴얼에는 목차 및 개요, 서문, 기본사항 등이 요약한 후 관련 내용의 시작 페이지를 함께 기술한다. 
> - 개요에는 설치 매뉴얼의 주요 특징, 구성과 설치 방법, 순서 등의 내용을 기술한다. 

#### 2. 서문 
- 서문에는 문서이력, 설치 메뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목을 기술한다. 
**1. 문서 이력** : 버전, 작성자, 작성일 ...
**2. 설치 매뉴얼의 주석** : 주의 사항과 참고 사항을 기술한다. 
**3. 설치 도구의 구성** : 설치 관련파일 / 폴더 및 설치 프로그램 실행 파일 / LOG 폴더에 대해 설명
**4. 설치 환경 체크 항목** : 사용자 환경 / 응용 프로그램 / 업그레이드 버전 / 백업 폴더 확인

#### 3. 기본 사항 
- 기본적으로 설명되어야 할 항목들은 다음과 같다. 
**1. 소프트웨어 개요** : 주요기능 및 UI, UI 및 화면 상의 버튼, 프래임 등을 그림으로 설명
**2. 설치 관련 파일** : 설치에 필요한 파일 설명 / exe, ini, log 등의 파일 설명
**3. 설치 아이콘**
**4. 프로그램 삭제**
**5. 관련 추가 정보**

#### 4. 설치 매뉴얼 작성 방법 
**1. 설치 화면 및 UI**
  - 설치 실행과 메인 화면 및 안내창에 대한 내용을 기술한다. 
  **(1) 설치 실행** : exe 등의 설치 파일을 실행할 수 있도록 실행 화면에 대한 이미지를 첨부하여 설명.
  **(2) 메인 화면 및 안내창** : 설치 시 나타나는 메인 화면과 각 과정에서의 안내창에 대한 이미지를 첨부하여 설명한다. 

**2. 설치 이상 메시지 설명**
 - 설치 방법이나 설치 환경이 잘못된 경우 표시될 수 있는 메시지에 대해 설명한다. 

**3. 설치 완료 및 결과**
- 설치가 정상적으로 마무리되었음을 사용자에게 최종적으로 알려준다. 

**4. FAQ** 
 - 설치 시 발생할 수 있는 다양한 상황을 FAQ로 정리하여 수록한다. 

**5. 설치 시 점검 사항**
- 설치에 필요한 사용자 계정 및 설치 권한에 대해 확인할 수 있도록 설명
- 설치 과정에서 오류가 발생한 경우 점검할 수 있는 사항들에 대해 설명 

**6. Netwoer 환경 및 보안**
- 네트워크 오류로 인해 설치 시 문제가 발생하지 않도록 사전에 필요한 네트워크 연결 상태를 점검하도록 안내
- 보안이나 방화벽으로 인해 설치 시 문제가 발생하지 않도록 관련된 내용을 안내


**7. 고객 지원 방법** 
- 문의할 수 있는 연락처를 안내

**8. 준수 정보 & 제한 보증**
- 사용 금지 등에 대한  준수사항을 안내
- 저작권자 소유권 정보 등과 관련된 내용을 안내

#### 5. 설치 매뉴얼 작성 순서 
> 1. 기능 식별 
> 2. UI분류
> 3. 설치 파일 / 백업 파일 확인
> 4. Uninstall 절차 확인
> 5. 이상 Case 확인
> 6. 최정 매뉴얼 적용

    
### 👏 045 소프트웨어 사용자 매뉴얼 작성(앞에 설치매뉴얼과 비교)

#### 1. 소프트웨어 사용자 매뉴얼의 개요 
- 사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성한다. 
- 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리한다. 
- 컴포넌트 단위로 매뉴얼을 작성한다. 
- 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설게서를 토대로 작성한다.
- 사용자 매뉴얼에는 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다. 


#### 2. 서문 
1. 문서이력 
2. 사용자 매뉴얼의 주석 : 주의사항과 참고 사항을 기술
3. 기록 보관 내용 
    - 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록 정보를 기술한다. 
    - 소프트웨어 명칭, 모델명, 문서 번호, 제품 번호, 구입 날짜

#### 3. 기본 사항
- 소프트웨어 개요 : 주요기능 및 UI 설명, 그림으로 설명
- 소프트웨어 사용 환경 : CPU, 메모리 등의 PC사양, 운영체제 버전 설명 / 소프트웨어 사용시 발생할 수 있는 프로그램 충돌이나 개인정보, 보안 등에 관한 주의사항을 설명한다
- 소프트웨어 관리 
- 모델, 버전별 특징
- 기능, 인터페이스의 특징
- 소프트웨어 구동 환경 : 개발에 사용한 언어 및 호환 가능한 운영체제에 대해 설명한다. 

#### 4. 사용자 매뉴얼 작성 방법 

>1. 사용자 화면 및 UI : 주의사항과 참고사항을 기술한다. 
    - 주의사항 : 소프트웨어를 사용할 때 사용자가 반드시 알고 있어야 하는 중요한 내용을 설명
    - 참고 사항 : 특별한 사용자의 환경이나 상황에 대한 내용을 설명한다.
>2. 주요 기능 분류 
    - 기능이 실행되는 화면을 순서대로 캡처하여 기능에 대한 사용법을 설명
>3. 응용 프로그램 및 설정
    - 소프트웨어 구동 시 함께 실행해도 되는 응용 프로그램, 또는 함께 실행되면 안 되는 응용 프로그램에 대해 설명한다. 
    - 소프트웨어가 정상적으로 구동되기 위한 설정이나 기본값에 대해 설명
>4. 장치 연동
    - 소프트웨어가 특정 장치에 내장되는 경우 연동 되는 장치에 대해 설명
>5. Network 환경
    -  Network에 접속되어 사용되는 소프트웨어인 경우 정상적인 연결을 위한 설정값 등을 설명
>6. Profile 안내
    - 사용자가 Profile의 경로를 변경하거나 위치를 이동하지 않도록 안내한다.
    - Profile과 같이 소프트웨어 구동에 필수적인 파일에 대해 설명한다. 
>7. 고객 지원 방법 
    - 연락처를 안내
>8. 준수 정보 & 제한 보증
    - 불법 등록 사용 금지, 지적 소유권 정보 등과 관련된 정보를 안내한다. 

#### 5. 사용자 매뉴얼 작성 순서

>1. 기능 식별
>2. 사용자 화면 분류
>3. 사용자 환경 파일 확인
>4. 초기화 절차 확인
>5. 이상 Case 확인 



### 👏 046 소프트웨어 버전 등록
#### 1. 소프트웨어 패키징의 형상 관리
- 형상 관리(SCM)은 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동이다.
> (1) 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 담당자에게 통보한다. 
> (2) 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행됨
> (3) 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다. 

#### 2. 형상 관리의 중요성
> - 지속적인 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있다.
> - 제품 소프트웨어에 대한 무절제한 변경을 방지할 수 있다. 
> - 발견된 버그나 수정 사항을 추적할 수 있다. 
> - 소프트웨어의 진행 정도를 확인하기 위한 기준으로 사용될 수 있다. 

#### 3. 형상 관리 기능
> - 형상 식별 : 형상 관리 대상에 이름과 관리 번호를 부여, 수정 및 추적이 용이하도록 하는 작업
> - 버전 제어 : 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리
> - 형상 통제 : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업 
> - 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
> - 형상 기록 : 형상의 식별, 통제, 감사 작업의 결과를 기록,관리하고 보고서를 작성하는 작업 

#### 4. 소프트웨어 버전 등록 관련 주요 용어
> - 저장소 : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장
> - 가져오기 : 아무것도 없는 저장소에 처음으로 파일을 복사
> - 체크아웃 : 프로그램을 수정하기 위해 저장소에서 파일을 받아온다
> - 체크인 : 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신
> - 커밋 : 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌을 알리고 수정한 후 갱신을 완료한다. 
> - 동기화 : 저장소에 있는 버전으로 자신의 작업 공간을 동기화한다. 

#### 5. 소프트웨어 버전 등록 과정(순서)
> (1) 가져오기 : 저장소에 신규로 파일을 추가한다. 
> (2) 인출
> (3) 예치
> (4) 동기화
> (5) 차이 


### 👏 047 소프트웨어 버전 관리 도구


#### 1. 공유 폴더 방식 (최근엔 거의 안 씀)
- 공유 폴더 방식은 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
> - 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사한다.
> - 담당자는 공유 폴더의 파일을 자기 pc로 복사한 후 컴파일 하여 이상 유뮤를 확인한다. 
> - 파일의 오류가 확인되면, 개발자에게 수정을 의뢰한다. 
> - 이상이 없다면 다음날 개발자들이 동작 여부를 다시 확인한다. 
> - 잘못 복사하는 것을 대비하기 위해 변경 사항을 데이터베이스에 기록하여 관리한다.  

#### 2. 클라이언트/서버 방식
- 클라이언트/서버 방식은 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식
> - 서버의 자료를 개발자가 자신의 pc(클라이언트)로 복사하여 작업 후 변경된 내용을 서버에 반영한다.  
> - 모든 버전 관리는 서버에서 수행됨
> - 단점 : 서버에 문제가 생기면 복구되기 전까지 작업이 중단됨
> - 대표적으로 SVC(Subversion)

#### 3. 분산 저장소 방식
- 분산 저장소 방식은 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
> - 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영한 다음 이를 원격 저장소에 반영한다. 
> - 장점 : 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 할 수 있다.
> - 대표적으로 Git이 있다. 

#### 4. Subversion(SVN)
> - 클라이언트/서버 구조로, 서버에는 최신 버전의 파일들과 변경 내역이 관리된다. 
> - 서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영(Commit)한다. 
> - 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에서 함.
> - 커밋(Commit)할 때마다 리비전이 1씩 증가한다.
> - 클라이언트는 대부분의 운영체제에서 사용되지만, 서버는 주로 유닉스를 사용한다. 
> - 무료로 사용 가능

#### 5. Git
> - Git은 분산 버전 관리 시스템으로 2개의 저장소, 지역(로컬)저장소와 원격 저장소가 존재
> - 지역 저장소는 개발자들이 실제 개발을 진행하는 장소로 버전관리가 수행됨
> - 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
> - 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하기 처리됨.
> - 원격 저장소나 네트워크에 문제가 있어도 작업이 가능
> - 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능
> - 파일의 변화를 스냅샷으로 저장하는데, 스냅샷의 포틴터를 가지므로 버전의 흐름을 파악 용이


### 👏 048 빌드 자동화 도구

#### 1. 빌드 자동화 도구란?
- 빌드란 소스 코드 파일들을 컴파일한 후 실행 파일로 만드는 과정이며, 이러한 빌드를 포함하여 테스트 및 배포를 자동화하는 도구를 빌드 자동화 도구라고 한다. 
- 대표적으로 Jenkins와 Grandle

#### 2. Jenkins
- Jenkins는 java 기반
- 서블릿 컨테이너에서 실행되는 서버 기반 도구
- SVN, Git등 대부분의 형상 관리 도구와 연동이 가능
- 친숙한 GUI 제공
- 분산 빌드나 테스트 가능

#### 3. Grandle
- Grandle은 Groovy기반 오픈소스 형태의 자동화 도구로, 안드로이드 앱 개발 환경에서 사용됨
- 안드로이드 뿐 아니라 플러그인을 설정하면 java c++ c python등의 언어도 빌드 가능
- DLS 스크립트 언어로 사용한다.
- 실행할 처리 명령들을 모아 태스트로 만든 후 태스크 단위로 실행한다. 
- 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능을 지원하므로 빌드의 속도를 향상시킬 수 있다. 


## 📚 4장 : 애플리케이션 테스트 관리

### 👏049 애플리케이션 테스트 

#### 1. 애플리케이션 테스트란?
- 애플리케이션에 잠재되어 있는 결함을 찾아내는 행위 
- 확인 : 고객의 요구사항을 만족시키는지(개발자 입장)
- 검증 : 소프트웨어가 기능을 정확히 수행하는지(사용자 입장)

#### 2. 소프트웨어의 분류 
  - 상용 소프트웨어
    - 산업 병용 소프트웨어
        > - 시스템 소프트웨어 : 하드웨어 전체를 제어하고 운영
        > - 미들웨어 : 운영체제와 응용 프로그램 사이에서 추가적인 서비스를 제공
        > - 응용 소프트웨어 : 특정 업무를 처리하기 위한 소프트웨어 
    - 산업 특화 소프트웨어
        > - 특정 분야에서 요구하는 기능만을 구현한 소프트웨어

- 서비스 제공 소프트웨어
    > - 신규개발 SW : 새로운 서비스를 제공하기 위해 개발됨
    > - 기능개선 SW : 사용자편의성, 속도, 화면 등의 기능을 개선하기 위한 개발됨
    > - 추가개발 SW : 환경 변화, 법이나 제도의 개정 등으로 개발됨
    > - 시스템통합 SW : 시스템별로 서비스 되던 것을 원스톱으로 제공하기 위해 통합 개발됨

#### 3. 애플리케이션 테스트의 필요성 
- 실행 전에 오류를 발견하여 예방할 수 있다. 
- 사용자의 요구사항, 기대 수준 등을 만족 시키는지 반복적으로 테스트해 신뢰도를 향상시킴
- 개발 초기부터 애플리케이션 테스트를 계획하고 시작하면 단순한 오류뿐 아니라 새로운 오류의 유입도 예방할 수 있다. 

#### 4. 애플리케이션 테스트의 기본 원리(중요)
- 완벽한 소프트웨어 태스팅은 불가능함
- 결함은 대부분 특정 모듈에 집중되어 있음(파레토 법칙)
- 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 '살충제 패러독스' 현상이 발생한다. 살충제 패러독스를 방지하기 위해서 테스트 케이스를 지속적으로 보완 및 개선해야 한다. 
- 정황에 따라 테스트를 다르게 수행해야 한다. 
- 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없다.(오류 부재의 궤변)
- 테스트와 위험은 반비례한다. 테스트를 많이 하면 할수록 미래에 발생할 위험을 줄일 수 있다. 
- 테스트는 작은 부분에서 시작하여 점점 확대하며 진행해야 함
- 테스트는 개발자와 관계없는 별도의 팀에서 수행한다. 

### 👏050 애플리케이션 테스트의 분류

#### 1. 프로그램 실행 여부에 따른 테스트 
- 정적 테스트 : 프로그램을 실행하지 않고 소스코드를 대상으로 분석하는 테스트(워크스루, 인스펙션, 코드검사)
- 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트로 소프트웨어 개발의 모든 단계에서 테스트를 수행할 수 있다. (블랙박스, 화이트박스 테스트)

#### 2. 테스트 기반에 따른 테스트 
- 명세기반 테스트 : 사용자의 요구사항에 대한 명세를 빠짐없이 테스트케이스로 만들어 구현하고 있는지 확인하는 테스트이다. (동등분할, 경계 값 분석)
- 구조기반 테스트 : 소프트웨어 내부의 논리 흐름에 따라 테스트 (구문기반, 결정기반, 조건기반)
- 경험기반 테스트 : 테스터의 경험을 기반으로 수행(에러 추정, 체크리스트, 탐색적테스팅)


#### 3. 시각에 따른 테스트 
- 검증 테스트 : 개발자의 시각에서 테스트
- 확인 테스트 : 사용자의 시각에서 테스트 

#### 4. 목적에 따른 테스트
- 회복 테스트 : 시스템에 결함을 준 후 올바르게 복구되는지 확인 
- 안전 테스트 : 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인
- 강도 테스트 : 과부하시에도 정상적으로 실행되는지 확인
- 성능 테스트 : 응답 시간, 처리량 등을 테스트
- 구조 테스트 : 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가
- 회귀 테스트 : 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
- 병행 테스트 : 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교
  

### 👏051 테스트 기법에 따른 애플리케이션 테스트 

#### 1. 화이트박스 테스트 (논리)
- 논리적인 모든 경로를 테스트 
- 설계된 절차에 초점을 둔 구조적 테스트 
- 모듈 안의 작동을 직접 관찰
- 원시 코드의 모든 문장을 한 번 이상 실행
- 프로그램의 제어 구조에 따라 분기점 부분들을 수행함으로써 논리적 경로를 제어한다.

#### 2. 화이트박스 테스트의 종류 

- 기초 경로 검사 
- 제어 구조 검사 
    > - 조건검사 : 모듈 내에 있는 논리적 조건을 테스트 
    > - 루프검사 : 반복 구조에 초점을 맞춰 실시
    > - 데이터 흐름 검사 : 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시


#### 3. 화이트박스 테스트의 검증 기준
- 문장검증기준 : 모든 구문이 한 번 이상 수행되도록 설계
- 분기검증기준 : 모든 조건문이 한 번 이상 수행되도록 설계
- 조건검증기준 : 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
- 분기/조건기준 : 모든 조건문과 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 설계

#### 4. 검증 기준의 종류 
- 기능 기반 커버리지 : 기능의 수 / 전체 기능의 수
- 라인 커버리지 : 소스 코드의 라인 수 / 전체 소스 코드의 라인 수 
- 코드 커버리지 : 구문, 분기, 조건 등의 구조 코드 자체가 얼마나 테스트 되었는지 측정 


#### 5. 블랙박스 테스트 (기능)
- 각 기능이 완전히 작동되는 것을 입증하는 테스트로 기능 테스트라고 한다. 
- 구현된 기능을 테스트
- 소프트웨어 인터페이스에서 실시되는 테스트
- 테스트 과정의 후반부에 적용 

#### 6. 블랙박스 테스트의 종류
- 동치 분할 검사 : 입력 자료에 초점을 맞춰 테스트. 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법 
- 경계값 분석 : 동치 분할 기법을 보완하기 위한 기법. 경계값에서 오류가 발생될 확률이 높다는점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법 
- 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 테스트 케이스를 선정
- 오류 예측 검사 : 경험이나 감각으로 테스트
- 비교 검사 : 여러 버전의 프로그램에 동일한 테스트를 제공하여 동일한 결과가 출력되는지 테스트

### 👏052 테스트 기법에 따른 애플리케이션 테스트 

#### 1. 단위 테스트 
- 단위 테스트는 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 처즘을 맞춤
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 함
    > - 구조 기반 테스트 : 화이트박스 테스트 
    > - 명세 기반 테스트 : 블랙박스 테스트

#### 2. 통합 테스트 
- 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
- 모듈 간 또는 통합된 컴포넌트 간의 상호작용 오류를 검사함

#### 3. 시스템 테스트 
- 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검
- 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트를 수행해야 함

> - 기능적 요구사항 : 요구사항 명세서, 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트
> - 비기능적 요구사항 : 화이트박스 테스트 
#### 4. 인수 테스트 
- 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트
- 개발한 소프트웨어를 사용자가 직접 테스트
- 인수 테스트에 문제가 없으면 사용자는 소프트웨어를 인수하고 프로젝트는 종료됨 
> - 사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부를 확인한다. 
> - 운영상의 인수 테스트 : 시스템 관리자가 수행하는 테스트 기법 
> - 계약 인수 테스트 : 계약상 인수 조건을 준수하는지
> - 규정 인수 테스트 : 정부 지침 법규에 맞게 개발 되었는지
> - 알파 테스트 : 사용자가 개발자 앞에서 행하는 테스트 
> - 베타 테스트 : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 

### 👏053 통합 테스트 (하스 상클)
- 통합테스트는 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법이다.
- 통합테스트 방법에는 비점진적 통합 방식과 점진적 통합 방식이 있다. 
- 비점진적 : 빅뱅 통합 테스트 방식
- 점진적 : 하향식, 상향식, 혼합식 

#### 1. 하향식 통합 테스트 
- 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
- 깊이 우선 통합법, 넓이 우선 통합법을 사용
- 하향식 통합 방법의 절차
> 1. 종속 모듈들은 **스텁**으로 대체 
> 2. 스텁들이 한 번에 하나씩 실제 모듈로 교체 
> 3. 통합 될 때마다 테스트 실시
> 4. 새로운 오류가 발생하지 않음을 보증하기 위해 회귀테스트 실시

#### 2. 상향식 통합 테스트 
- 하위 모듈에서 상위 모듈로 통합하면서 테스트
- 스텁이 아닌 **클러스터** 필요
- 상향식 통합 방법의 절차 
> 1. 클러스터로 결합
> 2. 드라이버를 작성 
> 3. 클러스터 단위로 테스트
> 4. 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체됨

- 테스트 드라이버와 테스트 스텁의 차이점 
    - 드라이버 : 상위 모듈 없이 하위 모듈이 있는 경우 하위 모듈 구동 
        - 이미 존재하는 하위 모듈과 존재하지 않는 상위 모듈 간의 인터페이스 역할을 함 
        - 개발이 완료되면 드라이버는 본래의 모듈로 교체됨
    - 스텁 : 상위 모듈은 있지만 하위 모듈이 없는 경우 하위 모듈 대체 
        - 임시로 제공되는 가짜 모듈의 역할을 함
        - 시험용 모듈이기 때문에 작성하기 쉬움
    - 공통점 : 소프트웨어 개발과 테스트를 병행할 경우 이용
  
#### 3. 혼합식 통합 테스트 
- 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원(샌드위치식 통합


#### 4. 회귀 테스팅 
- 이미 테스트된 프로그램의 테스팅을 반복하는 것. 통합 테스트로 인해 변경된 모듈이나 새로운 오류가 있는지 확인
- 회귀 테스트는 모든 테스트 케이스를 이용해 테스팅하는 것이 좋지만 시간과 비용 문제로 기존 테스트 케이스 중 변경된 부분을 테스트할 수 있는 테스트 케이스만을 선정하여 수행한다. 
- 테스트 케이스 선정 방법 
    > - 모든 애플리케이션 기능 수행할 수 있는 대표적인 테스트 케이스를 선정
    > - 파급 효과가 높은 부분이 포함된 테스트 케이스를 선정
    > - 실제 수정이 발생한 모듈 또는 컴포넌트에서 시행하는 테스트 케이스를 선정 


### 👏054 애플리케이션 테스트 프로세스 

- 애플리케이션 테스트 프로세스 : 개발된 소프트웨어가 사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트하는 절차
> 테스트 계획 ➡ 테스트 분석 및 디자인 ➡ 테스트 케이스 및 시나리오 작성 
> ➡ 테스트 수행 ➡ 테스트 결과 평가 및 리포팅 ➡ 결함 추적 및 관리 

- 테스트를 마치면 테스트 계획서, 테스트 케이스, 테스트 시나리오, 테스트 결과서가 산출된다. 
    > - 테스트 계획서 : 테스트 수행을 계획한 문서
    > - 테스트 케이스 : 테스트 항목의 명세서 
    > - 테스트 시나리오 : 테스트 케이스의 동작 순서를 기술한 문서 
    > - 테스트 결과서 : 테스트 결과를 비교, 분석 

#### 1. 테스트 계획
- 테스트 대상 시스템의 구조를 파악함
- 조직 및 비용을 산정함
- 테스트 시작 및 종료 조건을 정의함 
- 테스트 계획서를 작성함 

#### 2. 테스트 분석 및 디자인 
- 테스트에 대한 리스크 분석 및 우선순위를 결정함 
- 테스트 데이터, 테스트 환경, 테스트 도구 등을 준비 
> - 테스트 데이터의 종류
>      - 실제 데이터 : 실제 운영되는 데이터를 복제한 데이터 
>       - 가상 데이터 : 스크립트를 통해 인위적으로 만든 데이터 

#### 3. 테스트 케이스 및 시나리오 작성 
- 테스트용 스크립트를 작성 

#### 4. 테스트 수행 
- 테스트 환경을 구축한 후 테스트를 수행 
- 테스트의 실행 결과를 측정하여 기록 
> - 테스트 환경 구축 
>   - 가상시스템 : 가상 머신 기반의 서버 또는 클라우드 환경을 구축하고 네트워크는 VLAN와 같은 기법을 이용하여 논리적인 분할 환경을 구축 

#### 5. 테스트 결과 평가 및 리포팅 

- 테스트 결과를 비교 분석하여 테스트 결과서를 작성
- 결함을 중점적으로 기록
- 테스트가 종료되면 테스트 실행 절차의 리뷰 및 결과에 대한 평가를 수행하고 결과에 따라 실행 절차를 최적화하여 다음 테스트에 적용 

#### 6. 결함 추적 및 관리 
- 테스트를 수행한 후 결함이 어디에서 발생했는지, 어떤 종류의 결함인지 결함을 추적하고 관리 
- 동일한 결함 발견 시 처리 시간 단축 및 결함의 재발 등을 방지할 수 있다.

> - 결함 관련 용어
>   - 에러/오류 : 개발자, 분석가 등 사람에 의해 발생한 실수
>   - 결함/버그 : 에러/오류로 인해 소프트웨어 제품에 발생한 결함을 의미 

### 👏055 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 

#### 1. 테스트 케이스 
- 테스트 항목에 대한 명세서로 명세 기반 테스트의 설계 산출물에 해당
- 테스트 케이스를 미리 설계하면 테스트 오류를 방지할 수 있고 필요한 인력, 시간 낭비를 줄일 수 있음 

- 테스트 케이스 작성순서 
> 1. 테스트 계획 검토 및 자료 확보
> 2. 위험 평가 및 우선순위 결정
> 3. 테스트 요구사항 정의
> 4. 테스트 구조 설계 및 테스트 방법 결정
> 5. 테스트 케이스 정의
> 6. 테스트 케이스 타당성 확인 및 유지 보수 

#### 2. 테스트 시나리오 
- 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서 

#### 3. 테스트 시나리오 작성 시 유의사항 (중요)
- 시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오로 분리하여 작성해야 함 
- 사용자의 요구사항과 설계 문서 등을 토대로 작성해야 함
- 각각 테스트는 항목을 작성해야 함
- 유스케이스 간 업무 흐름이 정상적인지를 테스트할 수 있도록 작성해야 함 
- 개발된 모듈 또는 프로그램 간 연계가 정상적으로 동작하는지 테스트할 수 있도록 작성 

#### 4. 테스트 오라클
- 테스트 오라클 : 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 
- 테스트 오라클의 특징 
> - 제한된 검증 : 테스트 오라클의 모든 테스트 케이스에 적용할 수  없다
> - 수학적 기법 : 테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있다. 
> - 자동화 기능 : 자동화 할 수 있다.

#### 5. 테스트 오라클의 종류 
- 참(True) 오라클 : 발생된 모든 오류를 검출할 수 있다. 
- 샘플링(Sampling) 오라클 : 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공 
- 추정(Heuristic) 오라클 : 샘플링 오라클을 개선한 오라클. 나머지 입력 값은 추정으로 처리
- 일관성 검사(Consistent) 오라클 : 테스트 케이스의 수행 전과 후의 결과 값이 동일한지 확인 

### 👏056 테스트 자동화 도구

- 테스트 자동화 : 사람이 반복적으로 수행하던 테스트 절차를 자동화 도구를 적용함으로써 쉽고 효율적으로 테스트 수행할 수 있도록 한 것 
- 테스트 자동화 도구를 사용함으로써 휴먼에러를 줄이고 테스트의 정확성을 유지하면서 테스트의 품질을 향상시킬 수 있다. 

#### 1. 테스트 자동화 도구의 장점/단점 
- 장점 
> - 인력 및 시간을 줄일 수 있다. 
> - 향상된 테스트  품질을 보장 
> - 사용자 요구사항 등을 일관성 있게 검증할 수 있다. 
> - 객관적인 평가 기준을 제공한다. 
> - 테스트 결과를 그래프 등 다양한 표시 형태로 제공
> - UI가 없는 서비스도 정밀 테스트가 가능

- 단점
> - 테스트 자동화 도구의 사용 방법에 대한 교육 및 학습이 필요
> - 자동화 도구를 프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요
> - 비공개 상용 도구의 경우 고가의 추가 비용이 필요

#### 2. 테스트 자동화 수행시 고려사항(중요)
- 재사용 및 측정이 불가능한 테스트 프로그램은 제외
- 용도에 맞는 적절한 도구를 선택해서 사용
- 자동화 도구의 환경설정 및 습득 기간을 고려해 프로젝트 일정을 계획
- 반드시 프로젝트 초기에 테스트 엔지니어의 투입 시기를 계획 

#### 3. 테스트 자동화 도구의 유형 
1. 정적 도구 분석 : 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견하기 위해 사용됨
2. 테스트 실행 도구 : 스크립트 언어를 사용하여 테스트 실행
> - 데이터 주도 접근 방식 
>   - 스프레드시트에 테스트 데이터를 저장하고. 이를 읽어 실행하는 방식
>   - 테스트 케이스를 반복하여 실행 가능
> - 키워드 주도 접근 방식 
>   - 스프레드시트에 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 저장하여 실행하는 방식 

3. 성능 테스트 도구 : 성능의 목표 달성 여부를 확인함
4. 테스트 통제 도구 
5. 테스트 하네스 도구(중요) 
     - 테스트를 지원하기 위해 생성된 코드와 데이터를 의미. 
     - 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 함
  > - 테스트 하네스의 구성요소
  >     - 테스트 드라이버
  >     - 테스트 스텁 
  >     - 테스트 슈트 : 테스트 케이스의 집합
  >     - 테스트 케이스 : 사용자의 요구사항을 준수했는지 확인하기 위해 만들어진 테스트 항목의 명세서
  >     - 테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서
  >     - 목 오브젝트 : 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행 

#### 5. 테스트 수행 단계별 테스트 자동화 도구 
> 1. 테스트 계획 : 요구사항 관리
> 2. 테스트 분석/설계 : 테스트 케이스 생성
> 3. 테스트 수행 
>    - 테스트 자동화  : 효율성을 높임
>    - 정적 분석 : 코딩 표준, 런타임 오류 등을 검증
>    - 동적 분석 : 대상 시스템의 시뮬레이션을 통해 오류를 검출
>    - 성능 테스트 : 가상의 사용자를 생성하여 시스템의 처리 능력을 측정하는 도구 
>    - 모니터링 : 시스템 자원의 상태 확인 및 분석을 지원하는 도구 
> 4. 테스트 관리 
>       - 커버리지 분석 : 테스트 완료 후 테스트의 충분성 여부 검증 지원
>       -  형상 관리 : 테스트 수행에 필요한 다양한 도구 및 데이터 괸리
>       -  결함 관리/추적 : 테스트 시 발생한 결함 추적 및 관리 활동을 지원 


### 👏057 결함 관리
- 결함이란 : 스프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것을 의미
- 사용자가 예상한 결과와 실행 결과 간의 차이나 업무 내용과의 불일치 등으로 인해 변경이 필요한 부분도 결함에 해당됨


#### 1. 결함 관리 프로세스 
- 애플리케이션 테스트에서 발견된 결함을 처리하는 것 
- 순서
> 1. 결함 관리 계획
> 2. 결함 기록 : 결함 관리 DB에 등록
> 3. 결함 검토 : 결함을 수정할 개발자에게 전달
> 4. 결함 수정 : 개발자는 결함을 수정
> 5. 테스터는 수정한 내용을 확인
> 6. 결함 상태 추적 및 모니터링
> 7. 최종 결함 분석 및 보고서 작성 

#### 2. 결함 상태 추적

- 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야 함
- 결함 관리 측정 지표 
  > - 결함 분호 : 결함 수 측정
  > - 결함 추세 : 결함 수의 추이 분석
  > - 결함 에이징 : 특정 결함 상태로 지속되는 시간 측정 

#### 3. 결함 추적 순서 

1. 결함 등록 : 결함이 등록된 상태
2. 결함 검토 : 검토된 상태
3. 결함 할당 : 결함이 할당된 상태
4. 결함 수정 : 개발자가 결함 수정을 완료한 상태 
5. 결함 조치 보류 : 결함의 수정이 불가능해 연기된 상태로 재오픈을 준비중인 상태
6. 결함 종료 : 담당자가 종료를 승인한 상태
7. 결함 해제 : 담당자가 종료 승인한 결함을 검토하여 결함이 아니라고 판명한 상태 

#### 4. 결함 분류 
> - 시스템 결함 : 애플리케이션 환경이나 데이터베이스 처리에서 발생된 결함
> - 기능 결함 : 애플리케이션의 기획, 설계 업무 시나리오 등의 단계에서 유입된 결함
> - GUI 결함 : 사용자 화면 설계에서 발생된 결함
> - 문서 결함 : 기획자, 개발자, 사용자 간의 의사소통 및 기록이 원활하지 않아 발생된 결함

#### 5. 결함 심각도 
- High : 더이상 프로세스를 진행할 수 없도록 만드는 결함
- Medium : 부정확한 기능이나 에러 등과 같이 시스템 흐름에 영향을 미치는 결함
- Low : 부정확한 GUI, 에러 메시지 미출력, 화면상의 철자 오류 등 시스템 흐름에는 영향을 미치지 않는 결함

#### 6. 결함 우선순위
- 결함 우선순위는 결정적, 높음, 보통, 낮음 또는 즉시 해결, 주의 요망, 대기, 개선권고 등으로 분류됨

#### 7. 결함 관리 도구
- Mantis : 결함 및 이슈 관리 도구로 단위별 작업 내용을 기록할 수 있어 결함 추적도 가능함 
- Trac : 결함 추적은 물론 결함을 통합하여 관리할 수 있는 도구
- Redmine : 트로젝트 관리 및 결함 추적이 가능한 도구
- Bugzilla : 결함을 지속적으로 관리할 수 있는 도구로 결함의 심각도와 우선순위를 지정할 수도 있다. 


### 👏058 애플리케이션 성능 분석


#### 1. 애플리케이션 성능 
- 애플리케이션 성능 : 사용자가 요구한 기능을 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도를 나타냄 
> - 처리량 : 일정 시간 내에 애플리케이션이 처리하는 일의 양
> - 응답시간 : 요청을 전달한 시간부터 **응답이 도착할 때까지** 걸린 시간 
> - 경과시간 : 작업을 의뢰한 시간부터 **처리가 완료될 때까지** 걸린 시간 
> - 자원 사용률 : 의뢰한 작업을 처리하는 동안의 CPU 사용량 등 자원 사용률 

#### 2. 성능 테스트 도구 (이름 기억)
> - JMeter : 다양한 프로토콜을 지원하는 부하 테스트 도구
> - LoadUI : 서버 모니터링, 드레그엔드랍 등 사용자의 편리성이 강회된 부하 테스트 도구
> - OpenSTA : HTTP,HTTPS 포로토콜에 대한 부하 테스트 및 생산품 모니터링 도구

#### 3. 시스템 모니터링 도구 (이름 기억)
- 애플리케이션이 실행되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구 
> - Scouter : 실시간 모니터링, 튜닝에 최적화 / 애플리케이션의 성능을 모니터링,통제
> - Zabbix : 웹기반 서버, 서비스, 애플리케이션 등의 모니터링 도구 

#### 4. 애플리케이션 성능 저하 원인 분석 
- 필요 이상의 많은 데이터를 요청한 경우 
- 데이터베이스의 락이 해제되기를 기다리면서 애플리케이션이 대기하거나 타임아웃된 경우
- 커넥션 풀의 크기를 너무 작거나 크게 설정한 경우
- 미들웨어를 사용한 후 종료되지 않아 연결 누구사 발생한 경우
- 확정되지 않고 커넥션 풀에 반횐되거나, 불필요한 커밋이 자주 발생되는 경우
- 서버 소켓에 쓰기는 지속되나 읽기가 수행되지 않는 경우
- 대량의 파일을 업로드하거나 다운로드하여 처리 시간이 길어진 경우
- 외부 호출이 장시간 수행되거나 타임아웃된 경우
- 데이터 전송이 실패하거나 전송 지연으로 인해 데이터 손실이 발생한 경우


### 👏059 애플리케이션 성능 개선

#### 1. 소스 코드 최적화 (중요)
- 나쁜 코드는 배재하고, 클린 코드로 작성하는 것
- 클린 코드 : 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드 
- 클린 코드 작성 원칙 
    > - 가독성 : 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용
    > - 단순성 : 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/매소드/함수 등을 최소 단위로 분리
    > - 의존성 배제 : 코드가 다른 모듈에 미치는 영향을 최소화
    > - 중복성 최소화 : 코드의 중복을 최소화함 
    > - 추상화 : 상위클래스에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스에서 구현 

#### 2. 소스 코드 최적화 유형 
- 클래스 분할 배치 : 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고 크기를 작게 작성
- 느슨한 결합 : 클라스 간의 의존성 최소화 
- 코딩 형식 준수 : 
  - 줄바꿈 사용 
  - 종속 함수 사용 
  - 호출하는 함수는 선배치, 호출되는 함수는 후배치 
  - 지역 변수는 각 함수의 맨 처음에 선언 
  - 좋은 이름 사용 
  - 적절한 주석문 사용 

#### 3. 소스 코드 품질 분석 도구 
- 소스 코드 품질 분석 도구는 소스 코드의 코딩 스타일, 코드에 설정된 코딩표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스테드 결합 등을 발견하기 위해 사용하는 분석 도구

## 📚 5장 : 인터페이스 구현

### 👏060 모듈 간 공통 기능 및 데이터 인터페이스 확인 C
- 공통 기능은 모듈의 기능 중 공통적으로 제공되는 기능을 의미한다. 
- 테이터 인터페이스는 모듈 간 교환되는 데이터가 저장될 파라미터를 의미한다. 

#### 1. 인터페이스 설계서 
1. 일반적인 인터페이스 설계서 : 시스템의 인터페이스 목록, 각 인터페이스의 상세 데이터 명세, 각 기능의 세부 인터페이스 정보를 정의한 문서이다. 
> - 시스템 인터페이스 설계서 : 시스템 인터페이스 목록을 만들고 각 인터페이스 목록에 대한 상세 데이터 명세를 정의
> - 상세 기능별 인터페이스 명세서 : 각 기능의 세부 인터페이스 정보를 정의한 문서 
2. 정적, 동적 모형을 통한 인터페이스 설계서 : 다이어그램을 이용하여 만든 문서 
> - 인터페이스가 시스템의 어느 부분에 속하고 해당 인터페이스를 통해 트랜잭션의 종류를 확인할 수 있다. 


### 👏 061 모듈 연계를 위한 인터페이스 기능 식별 


#### 1. 모듈 연계란?
- 모듈 연계는 내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것
- 대표적으로 EAI와 ESB 방식이 있다. 

1. EAI 
- 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션 
- 비지니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성을 높여준다. 
- 구축유형은 다음과 같다.  p.267 참조 
> - Point to Point : 기본적인 방식으로 1:1로 연결, 변경 및 재사용 어렵다. 
> - Hub & Spoke : 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식, 확장 및 유지보수가 용이, 허브장애 발생 시 시스템 전체에 영향을 미침 
> - Message Bus : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식, 확장성이 뛰어나며 대용량 처리가 가능
> - Hybrid : Hub & Spoke 와 Message Bus의 혼합 방식, 그룹 내에서는 Hub & Spoke방식, 그룹 간에는 Message Bus방식을 사용, 데이터 병목 현상을  최소화 할 수 있다. 

1. ESB
- 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
- 특정 서비스에 국한되지 않고 범용적으로 사용하기 위해 애플리케이션과의 결합도를 약하게 유지한다.

#### 2. 모듈 간 연계 기능 식별 
- 모듈과 연계된 기능을 시나리오 형태로 구체화하여 식별한다. 

#### 3. 모듈 간 인터페이스 기능 식별 
- 인터페이스 동작에 필요한 기능을 식별한다. 
- 인터페이스 동작은 대부분 외부 모듈의 결과 또는 요청에 의해 수행됨
- 내부 모듈의 동작은 시나리오를 통해 기능을 식별한다. 
- 식별된 인터페이스 기능 중 실제적으로 필요한 인터페이스 기능을 최종적으로 선별한다. 
- 식별된 인터페이스 기능은 인터페이스 기능 구현을 정의하는데 사용된다. 

### 👏 062 모듈 간 인터페이스 데이터 표준 확인  C
- 인터페이스 데이터 표준은 모듈 간 인터페이스에 사용되는 데이터의 형식을 표준화 하는 것이다. 
- 인터페이서 데이터 표준은 기존의 데이터 중 공통 영역을 추출하거나 어느 한쪽의 데이터를 변환하여 정의한다. 
- 인터페이스 데이터 표준 확인 순서 
> 1. **데이터 인터페이스**를 통해 인터페이스 표준 확인
> 2. **인터페이스 기능**을 통해 인터페이스 표준 확인
> 3. **인터페이스 데이터 표준 확인**

#### 1. 데이터 인터페이스 확인
- 확인된 데이터 인터페이스의 각 항목을 통해 데이터 표준을 확인한다. 

#### 2. 인터페이스 기능 확인 

- 인터페이스 기능 구현을 위해 필요한 데이터 항목을 확인한다. 
- 데이터 표준에서 수정, 추가, 삭제될 항목이 있는지 확인한다. 

#### 3. 인터페이스 데이터 표준 확인
- 데이터 인터페이스에서 확인된 데이터 표준과 인터페이스 기능을 통해 확인된 데이터 항목들을 검토하여 최종적으로 데이터 표준을 확인한다.
- 확인된 데이터 표준은 항목별로 데이터 인터페이스와 인터페이스 기능 중 출처를 구분하여 기록한다.

### 👏 063 인터페이스 기능 구현 정의
- 인터페이스 기능 구현 : 인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술한 것이다. 
#### 1. 모듈 세부 설계서 
- 모듈 세부 설계서 : 모듈 구성 요소와 세부적인 동작 등을 정의한 설계서이다. 
- 대표적인 세부 설계서 : 컴포넌트 명세서 / 인터페이스 명세서 

1. 컴포넌트 명세서 : 컴포넌트의 개요, 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의한 것 
    - 컴포넌트 ID
    - 컴포넌트명
    - 컴포넌트 개요
    - 내부 클래스 
    - 인터페이스 클래스

2. 인터페이스 명세서 : 컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능을 정의한 것 
    - 인터페이스ID
    - 인터페이스명
    - 오퍼레이션명
    - 오프레이션 개요
    - 사전조건
    - 사후조건
    - 파라미터
    - 반환값 

#### 2. 모듈 세부 설계서 확인
- 각 모듈의 인터페이스에 필요한 기능을 확인한다. 
- 컴포넌트 명세서의 컴포넌트의 개요, 내부 클래스의 클래스명과 설명 등을 통해 컴포넌트가 가지고 있는 주요 기능을 확인
- 컴포넌트 명세서의 인터페이스 클래스를 통해 인터페이스에 필요한 주요 기능을 확인
- 인터페이스 명세서를 통해 컴포넌트 명세서의 인터페이스 클래스에 명시된 인터페이스 세부 조건 및 기능을 확인 

#### 3. 인터페이스 기능 구현 정의
- 일관성 있는 인터페이스 기능 구현 정의
  - 인터페이스의 기능, 인터페이스 데이터 표준, 모듈 세부 설계서를 통해 인터페이스의 기능 구현을 정의한다. 
  - 송수신 측에서 진행해야 할 절차까지 다시 세부적으로 정의한다. 
- 정의된 인터페이스 기능 구현 정형화
  - 정의한 인터페이스 기능 구현을 특정 하드웨어나 소프트웨어에 의존적이지 않게 사람들이 보기 쉽고 표준화되도록 정형화한다.
  - 가독성을 높이려면 프로세스 형태나 유스케이스 다이어그램 형태로 정형화한다.

### 👏 064 인터페이스 구현  C
- 인터페이스 구현 : 송수신 시스템 간의 데이터 교환 및 처리를 실현해주는 작업을 의미
- 대표적인 방법 : 데이터 통신을 이용한 방법 / 인터페이스 엔티티를 이용한 방법 
#### 1. 데이터 통신을 이용한 인터페이스 구현 
- 데이터 통신을 이용한 인터페이스 구현은 애플리케이션 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신 측에서 파싱하여 해석하는 방식이다.

#### 2. 인터페이스 엔티티를 이용한 인터페이스 구현
- 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티를 두어 상호 연계하는 방식
- 일반적으로 인터페이스 테이블을 엔티티로 활용한다.
- 인터페이스 테이블은 한 개 또는 송신 및 수신 인터페이스 테이블을 각각 두어 활용한다. 
- 송신 및 수신 인터페이스 테이블의 구조는 대부분 같지만 상황에 따라 서로 다르게 설계할 수도 있다. 

> JSON : 속성-값 쌍으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다. 
> XML : 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어다.

### 👏 065. 인터페이스 예외 처리
- 인터페이스 예외처리 : 구현된 인터페이스가 동작하는 과정에서 기능상 예외 상황이 발생했을 때 이를 처리하는 절차를 말한다. 
- 인터페이스 예외 처리는 (1) 데이터 통신을 이용한 방법과 (2) 인터페이스 엔티티를 이용한 방법이 있다. 

#### 1. 데이터 통신을 이용한 인터페이스 예외 처리 

- 발생할 수 있는 예외 케이스를 정의하고 각 예외 케이스마다 예외처리 방법을 기술한다. 
- 시스템환경, 송수신 데이터, 프로그램 자체원인 등 다양한 원인으로 인해 예외상황이 발생함

1.  인터페이스 객체 **송신 실패시** 예외 처리 방안
> - 시스템 환경 : 네트워크 불안정 - 오류 메시지확인, 404오류일 경우 네트워크 상태를 확인
> - 송신 데이터 : 송신 데이터 크기, 정합성 체크 오류 - 사전에 데이터를 정제, 정합성 체크기능 추가
> - 프로그램 자체 원인 : 송신데이터 생성 시 프로세스의 논리적 결함 - 논리적 결함을 수정 

2. 인터페이스 객체 **수신 실패시** 예외 처리 방안

> - 시스템 환경 : 네트워크 및 서버 불안정 - 입력 대기 큐에 요청 적재 후 순차적으로 처리
> - 수신 데이터 : 특수문자로 피싱시 오류 발생 - 오류 발생하지 않는 문자로 우선 대치 후 이후에 다시 처리
> - 프로그램 자체 원인 : 수신 데이터 처리 시 프로그램의 논리적 결함  - 예외사항이 수신되지 않도록 송신 측 프로그램을 수정 


#### 2. 인터페이스 엔티티를 이용한 인터페이스 예외 처리 

1. **송신** 인터페이스 테이블을 이용한 인터페이스  기능 실패시 예외처리 방안
> - 생성 : 선택SQL오류, 프로그램 오류, 생성 오류 - 사용자에게 알림, 프로그램 개선
> - 입력 : 입력SQL오류, 데이터 정합성 오류 - 입력실패 결과와 원인을 기록
> - 전송 : DB Connection 오류, 데이터 전송 주체의 논리적 오류 

2. **수신** 인터페이스 테이블을 이용한 인터페이스  기능 실패시 예외처리 방안

> - 읽기 : 데이터 선택 시 오류 
> - 트랜잭션 : 데이터 트랜잭션 시 프로그램의 논리상 오류 
> - 처리 결과 응답 : DB Connection 오류


### 👏 066. 인터페이스 보안
- 인터페이스는 충분히 보안 기능을 갖추지 않으면 시스템 전체에 악영향을 줄 수 있다. 
#### 1. 인터페이스 보안 취약점 분석
- 인터페이스 기능이 수행되는 각 구간들의 어떤 보안 취약점이 있는지 분석한다. 
- 인터페이스 기능이 수행되는 각 구간의 특징 등을 구체적으로 확인한다. 

#### 2. 인터페이스 보안 기능 적용 
- 인터페이스 보안 기능은 일반적으로 네트워크, 애플리케이선, 데이터베이스 영역에 적용한다. 

1. 네트워크 영역 
   - 인터페이스 송수신 간 스니핑 등을 이용한 데이터 탈취 및 변조 위험을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정한다. 
   - 암호화는 IPSec, SSL 등 다양한 방식으로 적용한다.
  2. 애플리케이션 영역 
     - 소프트웨어 개발 보안 가이드를 참조해 코드 상 보안 취약점을 보완하는 방향으로 보안기능을 적용

3. 데이터베이스 영역 

    - 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용 
    - 개인 정보나 업무상 민감한 데이터의 경우 암호화나 익명화 등 데이터 자체의 보안 방안도 고려 

### 👏 067. 연계 테스트 
- 연계 테스트 : 구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동이다. 
- 순서 
> 1. 연계 테스트 케이스 작성
> 2. 연계 테스트 환경 구축
> 3. 연계 테스트 수행
> 4. 연계 테스트 수행 결과 검증

#### 1. 연계 테스트 케이스 작성 
- 연계 테스트 케이스 작성은 연계 시스템 간의 데이터 및 프로세스의 흐름을 분석해 필요한 테스트 항목을 도출하는 과정이다. 
- 송수신용 연계 응용 프로그램의 단위 테스트 케이스와 연계 테스트 케이스를 각각 작성한다. 
1. 송수신용 연계 응용 프로그램의 단위 테스트 케이스
> - 송수신 시스템에서 확인해야 할 항목을 도출한다. 
> - 송수신 시스템에서 단순 개별 데이터의 유효값을 확인하는 경우의 수와 데이터 간 연관 관계를 확인하는 경우의 수로 구분하여 작성한다. 

2. 연계 테스트 케이스 
> - 응용 프로그램의 기능성 결함을 확인하는 단위 테스트 케이스 형태로 작성
> - 단위 테스트 케이스는 흐름을 확인할 수 있는 내용으로 작성 

#### 2. 연계 테스트 환경 구축 

- 연계 테스트 환경 구축은 테스트 일정, 방법, 절차, 소요 시간 등을 송수신 기관과 협의를 통해 결정 
- 연계서버 또는 송수신용 어댑터 설치, 연계를 위한 IP및 포트 허용 신청, 연계를 위한 DB 계정 및 테이블과 데이터 생성 등의 테스트 환경을 구축한다. 

#### 3. 연계 테스트 수행
- 연계 테스트 수행은 연계 응용 프로그램을 실행하여 연계 테스트 케이스의 시험 항목 및 처리 절차 등을 실제로 진행하는 것이다. 
- 송수신용 연계 응용 프로그램의 단위 테스트를 먼저 수행한다. 

#### 4. 연계 테스트 수행 결과 검증
- 연계 테스트 수행 결과 검증은 연계 테스트 케이스의 시험 항목 및 처리 절차를 수행한 결과가 예상 결과와 동일한지를 확인하는 것이다. 
- 연계테스트 수행결과는 다음과 같은 테스트케이스 항목별 검증 방법을 이용하여 검증한다. 
  > - 운영 DB 테이블의 건수를 확인하는 방법
  > - 테이블 또는 파일을 열어 데이터를 확인하는 방법
  > - 파일 생성 위치에서 파일 생성 여부 및 파일 크기를 확인하는 방법
  > - 모니터링 현황을 확인하는 방법
  > - 시스템에서 기록하는 로그를 확인하는 방법 

### 👏 068. 인터페이스 구현 검증
- 인터페이스 구현 검증 : 인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것 
- 인터페이스 구현 검증 도구와 감시도구를 이용하여 인터페이스의 동작 상태를 확인한다. 

#### 1. 인터페이스 구현 검증 도구 
- 인터페이스 구현을 검증하기 위해서는 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 필요
- 검증 도구
> - XUnit
> - STAF
> - FitNesse
> - NTAF
> - Selenium
> - watir

#### 2. 인터페이스 구현 감시도구 
- 인터페이스 동작 상태는 APM을 사용하여 감시할 수 있다. 
- 애플리케이션 성능 관리 도구를 통해 종합적인 정보를 조회하고 분석할 수 있다.
- 대표적인 애플리케이션 성능 관리 도구에는 스카우터, 제니퍼 등이 있다. 

#### 3. 인터페이스 구현 검증 도구 및 감시 도구 선택

- 인터페이스의 정상적인 동작 여부를 확인하기 위한 검증 도구와 감시도구의 요건을 분석
- 분석이 끝나면 적절한 인터페이스 구현 검증 도구와 감시도구를 선택한다. 

#### 4. 인터페이스 구현 검증 확인 
- 검증도구를 이요하여 동작 상태를 확인한다. 
- **예상되는 결과값과 실제 검증값이 동일한지** 비교
- 각 단계별 오류 처리도 적절하게 구현되어 있는지 확인

#### 5. 인터페이스 구현 감시 확인 
- 감시도구를 이용해 서비스를 제공하는 동안 **정상적으로 동작하는지** 확인
- 동작 여부, 에러 발생 여부 등 감시 도구에서 제공해 주는 리포트를 활용한다. 

### 👏 069. 인터페이스 오류 확인 및 처리 보고서 작성 C
 
 #### 1. 인터페이스 오류 발생 즉시 확인
- 인터페이스 오류가 발생하면 화면에 오류 메시지를표시하고 자동으로 SMS, 이메일을 발송하므로 즉시 오류 발생을 확인할 수 있다.

#### 2. 주기적인 인터페이스 오류 발생 확인
- 시스템 로그나 인터페이스 오류 관련 테이블 등을 통해 주기적으로 오류 발생 여부를 확인한다. 
> - 로그 확인 : 오류 발생 시 관련 오류를 별도의 로그 파일로 생성하여 보관
> - 테이블 확인 : 테이블에 오류사항을 기록
> - 감시도구 사용 : 스카우터나 제니퍼 등의 인터페이스 감시 도구를 사용해 주기적으로 확인 

#### 3. 인터페이스 오류 처리 보고서 작성
- 인터페이스 오류 처리 보고서 : 인터페이스 작동 시 발생하는 오류의 발생 및 종료 시점, 원인 및 증상, 처리사항 등을 정리한 문서다. 
- 정형화된 형식이 없어 조직 또는 오류 발생 시 상황에 맞춰 작성한다. 
- 시간 경과에 따라 기록 
- 다음은 보고 시기에 따른 인터페이스 오류 처리 보고서의 특징 
> 1. 최초 발생 시 : 신속하게 조직에 보고하고 대응 조직을 든다. 간이보고서, 이메일, SMS로 보고
> 2. 오류 처리 경과 시 : 오류 처리 진행 상황과 오류에 관한 공지사항 등록 등을 보고
> 3. 완료시 : 오류 발생 시점, 오류 처리 경과, 오류 재발 방지 대책 등 종합적인 내용을 보고한다. 