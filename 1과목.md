# ‍🏄‍♂️ 정보처리기사 자격증 

# 🐋1과목 : 소프트웨어 설계

## 📚 1장 : 요구사항 확인

### 👏 001 소프트웨어 생명 주기

1. 소프트웨어 생명 주기
   
- 소프트웨어를 개발하기 위해 정의, 운용, 유지보수 등의 과정을 단계별로 나눈 것
- 개발자는 개발 방법에 따라 특정 모형을 선택하여 사용할 수도, 개별적인 모형을 사용할 수도 있다. 
- 폭포수 모형 / 프로토타입 모형 / 나선형 모형 / 애자일 모형 

2. 폭포수 모형 (구식이네..)

- 가장 오래되고 폭넓게 사용된 고전적 생명주기 모형
- 한 단계가 끝나야만 다음 단계로 갈 수 있는 선형 순차적 모형
- 각 단계가 끝나면 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다. 
- 두 개 이상의 과정이 병행하여 수행되지 않는다. 
```
타당성검토 ➡ 계획 ➡ 요구분석 ➡ 설계 ➡ 구현(코딩) ➡ 시험(검사) ➡ 유지보수 
타계요설구시유~
```

3. 프로토타입 모형(원형)

- 사용자의 요구사항 정확히 파악하기 위해 견본을 만들어 최종결과물을 예측하는 모형 
- 개발이 완료된 시점에서 오류가 발견되는 폭포수의 단점을 보완하기 위한 모형
```
요구수집 ➡ 빠른설계 ➡ 프로토타입구축 ➡ 고객평가 ➡ 프로토타입조정 ➡ 구현
```
4. 나선형 모형(점진적)

- 보헴 제안, 폭포수와 프로토타입의 장점에 위험분석기능을 추가
- 점진적으로 완벽한 최종 소프트웨어를 개발
- 위험을 관리하고 최소화하는 것이 목적
- 정밀하며, 유지보수 과정이 필요 없다. 
```
계획 및 정의 ➡ 위험분석 ➡ 공학적 개발 ➡ 고객평가 
```
5. 애자일 모형 (기민한)

- 고객의 요구사항 변화에 유연하게 대응
- 고객과 소통에 초점을 맞춤
- 스프린트, 이터레이션이라는 짧은 개발 주기를 반복
- 소규모 프로젝트, 고도로  숙달된 개발자, 급변하는 요구사항에 적합
- XP, 스크럼 

```
    반복주기1           /           반복주기2               /           마지막반복주기
개발➡테스트➡설계               개발➡테스트➡설계                    개발➡테스트➡설계
```
6. 애자일 개발  4가지 핵심 가치
- 개인과 상호작용에 가치를 둠
- 문서보다는 실행되는 SW에 가치를 둠
- 계약 협상보단 고객과 협업에 가치를 둠
- 계획보단 변화에 반응하는 것에 가치를 둠

7. 애자일 개발 12가지 실행지침

- 유용한 소프트웨어를 빠르고 지속적으로 제공, 고객을 만족시킨다. 
- 개발 막바지라도 요구사항 변경을 적극 수용
- 몇 주 단위로 실행되는 소프트웨어를 제공
- 고객과 개발자가 함께 일한다.
- 의지가 확실한 사람들로 팀을 구성한다. 
- 개발 진척도 확인하는 1차 기준은 작동하는 소프트웨어다.
- 일정한 속도로 개발을 진행
- 단순화 추구
- 조직적인 팀
- 정기적으로 깊이 고민


### 👏 002 스크럼 기법 (애자일)
1. 제품책임자(PO)

- 주로 개발 의뢰자나 사용자가 담당한다. 이해도가 높은 사람
- 제품에 대한 요구사항을 작성하는 주체다. 
- 백로그를 작성하고 우선순위를 지정한다. 

2. 스크럼마스터(SM)

- 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언을 해주는 가이드 역할을 수행
- 개발 과정에서 발생된 장애 요소를 공론화하여 처리

3. 개발팀(DT)

- 개발자 외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람
- 7~8명 

4. 스크럼 개발 과정

```
백로그 작성 ➡ 스프린트 계획회의 ➡ 스프린트 수행(2~4주) ➡ 일일회의(매일15분) ➡ 검토회의 ➡ 회고
```

### 👏 003 XP기법 (애자일)
1. XP(익스트림 프로그래밍)

- XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여로 빠르게 개발하는 것이 목적
- 테스트마다 고객을 직접 참여시킴
- 소규모 인원의 개발 프로젝트에 효과적
- XP의 5가지 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백
- 릴리즈 테스트마다 고객 참여
```  
피존의 용단
```

2. XP 개발 프로세스 

- 사용자 스토리 : 고객의 요구사항을 간단한 시나리오로 표현 
- 릴리즈 계획 수립 : 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는것을 릴리즈 라고 함
- 스파이크 : 요구사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
- 이터레이션 : 하나의 릴리즈를 더 세분화 한 단위를 이터레이션이라고 한다.(1~3주)
- 승인 검사 : 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트이다. 
- 소규모 릴리즈 : 릴리즈를 소규모로 하게 되면, 고객의 반응을 기능별로 확인할 수 있어, 요구사항에 좀 더 유연하게 대응할 수 있다. 

3. XP 주요 실천 방법 

- Pair programming(짝 프로그래밍) : 다른 사람과 개발에 대한 책임을 공동으로  나눠갖는 환경조성
- Test Driven Development(테스트 주도 개발) : 실제 코드를 작성하기 전 테스트 케이스 먼저 작성
- Whole Team(전체 팀) : 구성원(고객포함)들은 각자 자신의 역할에 책임을 가져야 한다. 
- Continuous Intergration(계속적인 통합) : 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리되 때마다 지속적으로 통합됨
- Design Improvement(디자인개선) : 프로그램 기능의 변경없이, 단순화, 유연성 강화 등을 통해 시스템을 재구성한다.
- Small Releases(소규모릴리즈) : 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다. 

```
XP  : P T    W C    D S (피티 받는 화장실 동선)
```

### 👏 004 현행 시스템 파악 C

1. 현행 시스템 파악 절차(구기인 아소 하네 )
2. 시스템 구성파악 : 각 업무에 속하는 단위 업무 정보시스템들의 명칭, 주요 기능들을 명시한다. 
3. 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부기능, 세부 기능으로 구분하여 계층형으로 표시 
4. 데이터를 어떤 형식으로 주고받는지, 통신규약은 무엇을 사용하는지, 반드시 고려해야함

### 👏 005 개발 기술 환경 파악 C

1. 운영체제(os)

- 운영체제는 시스템 자원들을 효율적으로 관리, 사용할 수 있도록 환경을 제공하는 소프트웨어
- Windows, UNIX, Mac OS, iOS(상용), Linux, Android(오픈)

2. 운영체제 관련 요구사항 식별 시 고려사항

- 가용성 : 운영체제 고유의 장애 발생 가능성 / 메무리 누수 / 지속적인 패치 / 운영체제 결함
- 성능 : 대규모동시 사용자 요청에 대한 처리 / 대용량 파일 작업처리 / 지원가능한 메모리크기
- 기술 지원 : 제작업체의 안정적인 기술지원 / 여러 사용자들 간 정보 공유 / 오픈소스여부
- 주변기기 : 설치 가능한 하드웨어 / 여러 주변기기 지원여부
- 구축 비용 : 지원 가능한 하드웨어 비용 / 설치할 응용프로그램 라이센스정책 / 유지비용/ 소유비용

3. 데이터베이스 관리시스템(DBMS)

- 데이터베이스를 관리해주는 스프트웨어
- 데이터베이스의 구성. 접근방법, 유지관리에 대한 모든 책임을 짐
- Oracle, SQL, IMB

4. DBMS 관련 요구사항 식별 시 고려사항

- 가용성 : 장시간 운영의 장애 발생 가능성/ 결함등으로 인한 재가동 / 백업,복구 편의성
- 성능 : 대규모 데이터, 트랜잭션 처리 성능 / 튜닝 옵션의 다양한 지원 / 비용기반 질의 최적화지원
- 기술지원 : 안정적인 기술지원 / 여러 사용자들 간 정보공유 / 오픈소스여부 
- 상호 호환성 : 설치가능한 운영체제의 종류 / JDBC, ODBC와 호환여부
- 구축비용 : 라이선스 정책, 비용/ 유지관리 비용 / 총 소유 비용 

5. 웹 애플리케이션 서버(WAS)

- 사용자의 요구에 따라 변하는 동적 컨텐츠를 처리하기 위해 사용되는 미들웨어
- 데이터 접근, 세션관리, 트랜잭션 관리 등을 위한 라이브러리 제공
- Tomcat, JBoss, JEUS, WebLogic, WebShpere

6. 웹 애플리케이션 서버 관련 고려사항

- 가용성 : 장시간 운영의 장애발생가능성 / 결함으로 인한 패치설치 재가동 / 안정적인 트랜잭션 처리 / 이중화 지원
- 성능 : 대규모 트랜잭션 / 다양한 설정 옵션 지원 / 가비지 컬렉션의 다양한 옵션
- 기술 지원 : 제조업체의 안정적인 기술 지원 / 여러 사용자의 정보 공유 / 오픈소스 여부
- 구축 비용 : 라이선스 정책, 비용 / 유지관리 비용 / 총 소유비용

### 👏 006 요구사항 정의 

1. 기능 요구사항

- 시스템이 무엇을 하는지, 어떤 기능을 하는지
- 입력이나 출력으로 무엇이 포함되어야 하는지
- 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지
- 시스템이 반드시 수행해야 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능 

2. 비기능 요구사항

- 장비구성
- 성능
- 인터페이스
- 데이터
- 테스트
- 보안
- 품질
- 프로젝트관리
- 프로젝트지원0

3. 사용자 요구사항

- **사용자 관점**에서 본, 시스템이 제공해야 할 요구사항 
- 사용자를 위한 것으로 **친숙한 표현**으로 이해하기 쉽게 작성

4. 시스템 요구사항 

- **개발자 관점**에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항
- **전문적이고 기술적**인 용어
- 소프트웨어 요구사항이라고도 함

5. 요구 공학 
- 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 함

6. 요구사항 도출 

- 요구사항 도출은 소프트웨어 개발 생명 주기 동안 지속적으로 반복된다.
- 도출하는 기법에는 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등

7. 요구사항 분석

- 소프트웨어의 범위를 파악
- 소프트웨어와 주변 환경이 상호 작용하는 방법을 이해한다.

8. 요구사항 명세

- 요구사항 명세는 요구사항을 체계적으로 분석한 후 승인될 수 있도록 문서화하는 것을 의미함
- 요구사항을 문서화할 때는 **기능 요구사항은 빠짐없이 완전하고 명확하게 기술**해야하며, **비기능 요구사항은 필요한 것만 명확하게 기술**해야 한다. 

9. 요구사항 확인 

- 개발 자원을 요구사항에 할당하기 전 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
- 요구사항 명세서의 내용이 이해하기 쉬운지, 일관성은 있는지, 회사의 기준에는 맞는지, 누락된 기능은 없는지 등을 검증하는 것이 중요하다. 

10. 요구분석 단계
```
타당성 조사 ➡ 요구사항 추출 및 분석 ➡ 요구사항 명세화 ➡ 요구사항 검증 
```

### 👏 007 요구사항 분석 기법 
- 요구사항 중 명확하지 않거나 모호한 부분을 걸러내기 위한 방법

1. 요구사항 분류

- 기능 요구사항과 비기능 요구사항으로 분류
- 상위 요구사항에서 유도된 것인지 다른 원천으로부터 직접 발생한 것인지 분류 
- 개발할 제품에 관한 것인지, 개발 과정에 관한 것인지 분류
- 우선순위에 따라 분류
- 소프트웨어에 미치는 영향의 범위에 따라 분류
- 소프트웨어 생명 주기 동안에 변경될 가능성이 있는지 여부에 따라 분류

2. 개념 모델링

- 요구사항을 보다 쉽게 이해할 수 있도록 현실세계 상황을 단순화하여 개념적으로 표현한 것
- 요구사항을 이해하는 이해관계자별로 관점이 다양하므로 그에 맞게 개념 모델도 다양하게 표현되어야 한다. 
- 모델링 표기는 주로 UML을 사용한다. 

3. 요구사항 할당

- 요구사항할당은 요구사항을 만족시키기 위한 구성 요소를 식별하는 것이다.
- 식별된 구성 요소들 간에 어떻게 작용하는지 분석하는 과정에서 추가적인 요구사항이 발견될 수 있다. 

4. 요구사항 협상 

- 요구사항이 서로 충돌될 경우 이를 적절히 해결하는 과정이다. 
- 요구사항이 서로 충돌되면 어느 한 쪽으로 맞추기보다는 적절한 기준점을 찾아 합의해야 함
- 두 명의 이해관계자가 요구하는 요구사항이 서로 충돌되는 경우
- 요구사항와 자원이 서로 충돌되는 경우
- 기능 요구사항와 비기능 요구사항이 서로 충돌되는 경우
- 요구사항이 서로 충돌되는 경우 각각에 우선순위를 부여하면 문제 해결에 도움이 될 수 있다. 

5. 정형 분석 

- 구문과 의미를 갖는 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현한 후 분석하는 과정이다. 
- 요구사항 분석의 마지막 단계에서 이뤄진다. 

### 👏 008 요구사항 확인 기법

1. 요구사항 검토 
- 문서화된 요구사항을 훑어보면서 확인하는 것, 가장 일반적인 요구사항 검증방법이다. 
- 요구사항 검토자 그룹을 구성할 때는 구성 방법이 중요하다. 예로 고객 중심 프로젝트에 대한 검토자 그룹에는 고객 대표자가 꼭 포함되어야 하기 때문이다. 
- 검토는 **시스템 정의서, 시스템 사양서, 소프트웨어 요구사항 명세서** 등을 완성한 시점에 이뤄진다. 

2. 프로토타이핑

- 초기 도출된 요구사항을 토대로 프로토타입을 만든 후 시스템 개발이 진행되는 동안 도출되는 요구사항을 반영하면서 지속적으로 프로토타입을 재작성하는 과정이다. 
- 상품이나 서비스가 출시되기 전 개발 대상 시스템 또는 그 일부분을 개략적으로 만든 원형을 프로토타입이라고 한다. 
  
```
장점 : 피드백 가능 / 사용자와 개발자의 의사소통 원활 / 시스템 사용에 대한 문제점을 시스템 완성 전 식별가능 
```
```
단점 : 핵심에서 벗어나 프로토타입 제작에만 집중될 가능성 / 사용성의 과대평가 / 지속적인 프로토타입 개선으로인한 비용문제
```

3. 모델 검증 

- 요구사항 분석 단계에서 개발된 모델이 요구사항을 충족시키는지 검증하는 것
- 정적분석을 수행하는 것이 유용
- 정적분석이란 실행을 통한 확인이 아닌 명세서의 정확성이나 일관성 등을 확인하거나 분석 도구를 사용해 확인하는 방법이다. 

4. 인수테스트 

- 사용자가 실제로 사용될 환경에서 요구사항들이 모두 충족되는지 사용자 입장에서 확인하는 과정

### 👏 009 UML

1. UML이란 

- 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어(시각적표현가능)이다. 
- 객체 기술에 관한 국제표준화기구인 OMG에서 표준으로 지정함

2. 사물

- 구조사물 : 시스템의 개념적, 물리적 요소(클래스, 유스케이스,컴포넌트, 노드)
- 행동사물 : 시간과 공간에 따른 요소들의 행위를 표현, 상호작용, 상태머신
- 그룹사물 : 요소들을 그룹으로 묶어서 표현(패키지)
- 주해사물 : 부가적인 설명이나 제약조건 등을 표현(노트)

3. 관계 
- 연관관계
```
- 2개 이상의 사물이 서로 관련되어 있음
- 사물 사이를 실선으로 연결, 방향성은 화살표로 표현
- 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결

1 : 1개의 객체가 연관
n : n개의 객체와 연관
0..1 : 연관된 객체가 없거나 1개만 존재
0..* 또는 * : 연관된 객체가 없거나 다수일 수 있다. 
1..* : 연관된 객체가 적어도 1개 이상
n..* : 연관된 객체가 적어도 n개 이상
n..m : 연관된 객체가 최소 n개에서 최대 m개
```
- 집합관계 
``` 
하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.
- 포함하는 쪽과 포함되는 쪽은 서로 독립적이다
- 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현한다. 
```
- 포함관계 

```
서로 독립될 수 없고 생명주기를 함께한다. 
포함되는 쪽에서 포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현
```

- 일반화관계 
```
하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다. 
일반적인 개념을 상위, 구체적인 개념을 하위라고 부른다.
구체적인 사물에서 일반적인 사물 쪽으로 빈 화살표를 연결
```
- 의존관계 
```
영향을 주는 사물이 영향을 받는 사물 쪽으로 점선 화살표를 연결하여 표현
```
- 실체화관계
```
사물이 할 수 있거나 해야하는 기능으로 서로를 그룹화 할 수 있는 관계를 표현한다. 
사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현한다. 
```

4. 다이어그램 

- 구조적 다이어그램의 종류(정적)
```
클래스  /   객체    /   컴포넌트    /   배치    /   복합체  /   패키지\
```
- 행위 다이어그램의 종류(동적)

```
유스케이스  /   시퀀스  /   커뮤니케이션    /   상태    /   활동    /   상호작용개요    /   타이밍
```

## 📚 2장 : 요구사항 확인

### 👏  010 사용자 인터페이스

1. 사용자 인터페이스의 세 가지 분야

- 정보 제공과 전달을 위한 물리적 제어에 관한 분야
- 컨텐츠의 상세적인 표현과 전체적인 구성에 관한 분야
- 편리하고 간편하게 사용하도록 하는 기능에 관한 분야

2. 사용자 인터페이스의 특징

- 사용자의 편리성과 가독성을 높임으로써 작업 시간을 단축시키고 업무에 대한 이해도를 높여준다. 
- 최소한의 노력으로 원하는 결과를 얻을 수 있게 한다. 
- 수행 결과의 오류를 줄인다. 
- 만연한 작업 기능에 대해 구체적인 방법을 제시해줌
- 정보 제공자와 공급자 간의 매개 역할을 수행함
- 사용자 인터페이스를 설계하기 위해선 소프트웨어 아키텍처를 반드시 숙지해야함 

3. 사용자 인터페이스의 구분

- CLI(Command Line Interface) : 명령과 출력이 텍스트 형태
- GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우스로 선택
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작함

4. 사용자 인터페이스의 기본 원칙

- 직관성 : 누구나 쉽게 이해하고 사용
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다. 
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

5. 사용자 인터페이스의 설계 지침

- 사용자 중심 : 사용자가 쉽게 이해하고 편리하게 사용
- 일관성 : 버튼이나 조작 방법을 일관성 있게 제공
- 단순성 
- 결과예측가능 : 작동시킬 기능만 보고도 결과 예측 가능하게 설계해야함
- 가시성
- 표준화 : 구조, 디자인을 표준화하여 한 번 학습한 이후에는 쉽게 사용할 수 있도록 설계
- 접근성 : 사용자의 연령, 성별, 인종등 다양한 계층이 사용할 수 있도록
- 명확성
- 오류 발생 해결 


### 👏 011 UI 표준 및 지침

- UI 표준 : 전체 시스템에 포함된 모든 UI에 공통적으로 적용될 내용, 화면 구성이나 화면 이동 등이 포함됨
- UI 지침 : UI 개발 과정에서 꼭 지켜야 할 공통의 조건을 의미함

1. 웹의 3요소 

- 웹 표준 : 웹에서 사용되는 규칙 또는 기술을 의미
- 웹 접근성 : 누구나, 어떤 환경에서도 웹 사이트에서 제공하는 모든 정보를 접근하여 이용할 수 있도록 보장
- 웹 호환성 : 다른 환경에서도 모든 이용자에게 동등한 서비스를 제공하는 것을 의미

2. 한국형 웹 콘텐츠 접근성 지침

- '한국형 웹 콘텐츠 접근성 지침'은 장애인이 비장애인과 동등하게 접근할 수 있는 웹콘텐츠의 제장방법을 제시한다.
- 접근성이 보장된 웹 콘텐츠를 쉽게 제작할 수 있도록 도와줌
- 웹 접근성의 준수 여부를 평가할 수 있는 요구조건과 이를 모두 준수할 경우 얻을 수 있는 기대효과가 제시되어있음

3. 웹 콘텐츠 접근성 지침 준수를 위한 고려사항

- 인식의 용이성 

>대체 텍스트 : 텍스트가 아닌 이미지 등의 콘텐츠에는 그 의미를 인식할 수 있는 대체 텍스트를 제공해야함
>멀티미디어 대체 수단 : 멀티미디어 콘텐츠에 대한 이해도를 높일 수 있도록 대체 수단을 제공
명료성 : 콘텐츠는 색이나 명도, 방향, 모양,크기 등에 관계없이 명확하게 전달될 수 있어야 한다. 

- 운용의 용이성 

>키보드 접근성 : 콘텐츠는 키보드만으로도 접근할 수 있어야 함
충분한 시간 제공 : 콘텐츠를 읽고 사용하는 데 충분한 시간을 제공해야 함
광과민성 발작 예방 : 광과민성 발작을 일으킬 수 있는 콘텐츠는 제공 X
쉬운 네이게이션 : 반복 영역은 건너뛸 수 있도록 하거나 링크 텍스트를 제공하는 등 쉽게 네이게이션 가능해야함

- 이해의 용이성 

>가독성
예측가능성
콘텐츠의 논리성 : 선형구조로 작성, 논리적인 순서를 제공
입력도움 : 입력 오류를 방지하거나 정정할 수 있어야 함

- 견고성 
 
>문법 준수 : 웹 콘텐츠는 마크업 언어의 문법을 준수해야 한다.
접근성 :

4. 전자정부 웹 표준 준수 지침

- 전자정부 웹 표준 준수 지침은 정부기관의 홈페이지 구축 시 반영해야 할 최소한의 규약을 정의한 것으로, 모든 사람이 시스템 환경에 구해받지 않고 정부기관의 홈페이지를 이용할 수 있도록 위한 것이다. 


> 내용의 문법 준수 : 모든 웹 문서는 적절한 문서타입을 명시하고 사용할 인코딩 방식을 표기해아함
> 내용과 표현의 분리 : 논리적인 마크업 언어를 사용하여 웹 문서를 구조화 한다. 표준적인 문법을 준수
> 동작의 기술 중립성 보장 : 스크립트의 비표준 문법을 확장하는 것은 배체, 대체 텍스트나 정보를 제공
> 플러그인의 호환성 : 다양한 웹 브라우저에서 호환되는 것을 사용
> 컨텐츠의 보편적 표현 : 메뉴는 다양한 브라우저에서 접근할 수 있어야 한다. 웹 사이트를 다양한 인터페이스로 이용할 수 있어야 한다. 
> 운영체제의 독립적인 컨텐츠 제공 : 제공되는 미디어는 운영체제에 종속적이지 않은 범용적인 포맷을 사용
> 부가기능의 호환성 확보 : 실명인증, 정자인증 등 부가 기능은 다양한 브라우저에서 사용할수 있어야 함
> 다양한 프로그램 제공 : 다양한 브라우저에서 정보를 열람 가능


### 👏 012 UI 설계 도구

- UI 설계 도구 종류 : 와이어프레임 , 목업, 스토리보드, 프로토타입, 유스케이스
  
1. 와이어프레임
- 기획 단계의 초기에 제작하는 것, 페이지의 개략적인 레이아웃, UI요소 등에 대한 뼈대를 설계하는 단계
- 툴 : 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵

2. 목업

- 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형(실제로 구현되지는 않는다.)
- 툴 : 파워 목업, 발사믹 목업

3. 스토리보드 

- 디자이나와 개발자가 최종적으로 참고하는 작업 지침서
- 좌측에는 UI화면, 우측에는 디스크립션(화면 설명)을 기입한다.
- 툴 : 파워포인트, 키노트, 스케치, Axure

4. 프로토타입

- 와이어프레임이나 스토리보드 등에 인터렉션을 적용해, 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
- 프로토타입은 페이퍼 프로토타입과 디지털 프로토타입으로 나뉜다. 
- 툴 : HTML/CSS AXURE, Flinto 네이버 프로토나우, 카카오 오븐

5. 유스케이스 

- 유스케이스는 사용자 측면에서의 요구사항을 달성하기 위해 수행할 내용을 기술한다.
-  자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것으로 다이어그램 형식으로 묘사된다. 
-  다이어그램이 완성되면, 각각의 유스케이스에 대해 유스케이스 명세서를 작성한다. 

### 👏 013 UI 요구사항 확인
-  UI 요구사항 확인 순서 : 목표정의 ➡ 활동사항 정의  ➡ UI요구사항 작성


1. 목표 정의 : 사용자를 대상으로 인터뷰를 진행한 후 사용자 의견을 수렴해 요구사항을 정의한다
>- 인터뷰 진행시 유의사항
    1. 인터뷰는 가능하면 개별적으로 진행
    2. 가능한 많은 사람을 인터뷰해 다양한 의견을 수렴하되 다수의 의견으로 인해 개인의 의견을 놓치지 않도록 함
    3. 인터뷰는 한 시간을 넘지 않도록 한다. 
    4. 인터뷰 진행은 반드시 사용자 리서치를 시작하기 전에 해야 한다. 


2. 활동 사항 정의 : 앞으로 해야 할 활동 사항을 정의한다. 
> - 사용자와 회사의 비전을 일치시키는 작업
> - 필요한 예산과 일정을 결정한다. 
> - 기술의 발전 가능성을 파악하고 UI디자인의 방향을 제시한다.
> - 사업 전략 및 목표, 프로세스의 책임자 선정, 회의 일정 및 계획 작성, 우선순위의 선정, 개별단위 업무를 구분한다. 

3. UI 요구사항 작성 

> - UI 요구사항은 반드시 실사용자 중심으로 작성되어야 한다. 
> - 여러 사람의 인터뷰를 통해 다양한 의견을 수렴해서 작성해야 한다.
> - UI의 전체적인 구조를 파악 및 검토해야 한다. 
> 작성 순서 : 요구사항 요소 확인 ➡ 정황 시나리오 작성  ➡ 요구사항 작성

4. 요구사항 요소 확인 

> - 데이터 요구 : 데이터 객체들을 정리한다.
> - 기능 요구 : 무엇을 실행해야 하는지를 동사형으로 설명한다. 
> - 제품/서비스의 품질 : 데이터 및 기능 요구 외에 제품의 품질, 서비스, 여기에 감성적인 품질 등을 고려해 작성
> - 제약 사항 : 제품 완료 데드라인, 전체 개발 및 제작에 필요한 비용, 시스템 준수에 필요한 규제가 포함된다.

5. 정황 시나리오 작성 

> - 사용자의 요구사항을 도출하기 위해 작성되는 것으로, 사용자가 목표를 달성하기 위해 수행하는 방법을 순차적으로 묘사한 것 
> - 요구사항 정의에 사용되는 초기 시나리오다. 
> - 육하원칙에 따라 간결, 명확하게 작성
> - 외부 전문가, 경험 풍부한 사람에게 검토 의뢰

6. 요구사항 작성 : 요구사항은 정황 시나리오를 토대로 작성한다. 

### 👏 014 품질 요구사항 

- ISO/IEC 9126 : 소프트웨어의 품질 평가를 위한 표준 지침으로 국제표준이다
- ISO/IEC 25010 : 9126에 비해 호환성과 보완성 부분이 강화됨 
  
1. 기능성 : 적절, 정합성    /  정밀,정확성  /  상호운용성  /   보완성  /   준수성
2. 신뢰성 : 성숙성  /   고장 허용성   / 회복성
3. 사용성 : 이해성  /   학습성   /   운용성  /   친밀성  
4. 효율성 : 시간 효율성  /  자원 효율성  /  
5. 유지 보수성 : 분석성  /  변경성  /  안정성  /  시험성 
6. 이식성 : 적용성  /  설치성  /  대체성  /  공존성


### 👏 015 UI 프로토타입 제작 및 검토

1. UI 프로토타입의 개요 

- 프로토타입은 사용자 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적인 형태의 모형으로 테스트가 가능
- 최종 제품의 작동 방식을 이해 시키는데 필요한 기능은 반드시 포함되어야 한다. 
- 요구사항이 모두 반영될 때까지 계속해서 개선하고 보완해야함
- 실제 사용자를 대상으로 테스트하는 것이 좋다.

2. UI 프로토타입의 장단점 
> - 장점 
>   1. 사용자를 설득하고 이해시키기 쉽다. 
>   2. 요구사항과 기능의 불일치 등으로 인한 혼선 예방으로 개발시간을 줄일 수 있다. 
>   3. 사전에 오류를 발견할 수 있다. 

> - 단점 
>   1. 프로토타입에 사용자의 모든 요구사항 반영하기 위한 반복적인 작업 때문에 작업 시간을 증가시키고 필요 이상으로 자원을 소모할 수 있다. 
>   2. 부분적으로 프로토타이핑을 진행하면 중요한 작업이 생략될 수 있다. 

3. 프로토타이핑의 종류 
> (1) 페이퍼 프로토타입 : 아날로그적 방법, 스케치, 그림 글 등 손으로 직접 작성(제작기간, 제작비용 적을 때 사용)
> - 장점 : 저렴, 즉시변경 가능, 고객이 과대한 기대를 하지 않음 
> - 단점 : 테스트에 부적당, 상호관계가 많은 경우 나타내기 복잡, 여러 사람들에게 나눠주거나 공유 어려움

> (2) 디지털 프로토타입 : 파워포인트, 아크로뱃 사용. 재사용이 필요하거나 산출물과 비슷한 효과 필요하거나, 숙련된 전문가가 있을 경우 사용
> - 장점 : 최종제품과 비슷하게 테스트 가능, 수정 용이, 재사용 가능
> - 단점 : 프로토타입을 작성할 프로그램의 사용법을 알아야 한다. 


4. UI 프로토타입 계획 및 작성 시 고려사항 

- 계획 시 고려 사항
> - 프로토타입의 개발 목적을 확인
> - 개발에 필요한 환경 마련
> - 실제 분석 작업이 완료되기 전에 진행해야 함 
> - 프로토타입 개발 인원을 확인
> - 프로토타이핑을 진행하면서 분석, 설계, 개발, 테스트 등의 표준 가이드를 확정한다. 
> - 프로토타이핑을 진행하면서 많은 시간이 소요된 구간을 찾고 그 원인을 분석하고 해결한다.
> - 고객과 프로젝트 매니저, 프로젝트 리더 등에게 완성된 프로토타입을 시연하다.

- 작성 시 고려사항
> - 프로토타입의 작성 계획을 세운다.
> - 주변 여건을 감안해서 프로토타입의 범위를 정한다. 
> - 프로토타입을 통해 얻고자 하는 목표를 확인한다. 
> - 개발 목표를 달성하기 위해 필요한 최소한의 기간과 비용을 확인하다. 
> - 완성된 프로토타입이 실제 개발에 참조될 수 있는지 확인한다. 
> - 프로토타입으로 검증할 범위가 너무 넓거나 기간이 길면 목표가 커져서 문제가 될 수 있으니 주의한다. 


5. UI 프로토타입 제작단계

- 1단계 : 사용자의 요구사항을 분석
- 2단계 : 프로토타입은 개발할 시스템의 핵심적인 기능 중심으로 개발
- 3단계 : 요구수행을 잘하고 있나 사용자가 직접 확인하는 단계. 다양한 추가, 수정의견 제안 가능
- 4단계 : 작성된 프로토타입을 기반으로 수정과 합의가 이뤄지는 단계, 보완작업을 한다. 작업이 완료된 후 3단계로 돌아간다. 사용자가 최종적으로 승인을 완료할 때까지 3단계와 4단계가 반복된다. 


### 👏  016 UI 설계서  작성

1. UI 설계서란?

   - UI 설계를 구체화하여 작성하는 문서
   - UI 설계서는 기획자, 개발자, 디자이너 등과 원활한 의사소통을 위해 작성한다. 

2. UI 설계서 표지 작성
   - UI 설계서 표지는 다른 문서와 혼동되지 않도록 프로젝트명 또는 시스템명을 포함시켜 작성한다. 

3. UI 설계서 개정 이력 작성 
   - UI 설계서 개정 이력은 UI 설계서가 수정될 때마다 어떤 부분이 어떻게 수정되었는지를 정리해 놓은 문서이다. 
   - 초안 버전을 1.0으로 설정하고 변경사항이 있을 때마다 변경 내용을 적고 0.1씩 높인다. 

4. UI 요구사항 정의서 작성 

   - 사용자의 요구사항을 확인하고 정리한 문서로, 사용자 요구사항의 UI 적용여부를 요구사항별로 표시한다. 

5. 시스템 구조 작성

   - 시스템 구조는 UI 요구사항과 UI프로토타입에 기초하여 전체 시스템의 구조를 설계한 것으로 사용자의 요구사항이 어떻게 시스템에 적용되는지 알 수 있다. 

6. 사이트맵 작성 

    - 시스템 구조를 바탕으로 사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것이다. 
    - 사이트 맵을 작성한 후 상세내용을 표 형태로 작성한다. 

7. 프로세스 정의서 작성


    - 사용자 관점에서 사용자가 요구하는 프로세스들을 작업 진행 순서에 맞춰 정리한 것으로 UI의 전체적인 흐름을 파악할 수 있다. 

8. 화면 설계 

    - 화면 설계는 UI프로토타입과 UI프로세스를 참고하여 필요한 화면을 페이지별로 설계한 것이다. 
    - 화면을 구분하기 위해 화면별 고유 ID를 부여하고 별도 표지를 작성한다. 


### 👏 017 UI 유용성 평가

1. UI 유용성 평가 

- 유용성은 사용자가 시스템을 통해 원하는 목표를 얼마나 효과적으로 달성할 수 있는가에 대한 척도
- 사용자 측면에서 복잡한 시스템을 얼마나 편리하게 상요할 수 있는지 평가하는 것으로, 시스템의 문제점을 찾아내고 개선 방향을 제시하기 위한 조사 과정이다. 
- 유용한 UI를 설계하기 위해서는 사용자가 생각하는 사용자 모형과 시스템 설걔자가 만드려는 개발자 보형 간 차이를 최소화해야됨 
- 사용자 모형과 개발자 모형 간의 차이가 발생하는 원인 
    (1) 실행 차 : 실행 **기능**이 다르기 때문에 발생    // 실 기
    (2) 평가 차 : 실행 **결과**가 다르기 때문에 발생    // 평 결

2. 실행 차를 줄이기 위한 UI 설계 원리 검토

- 사용 의도 파악 : 사용자의 목적을 명확히 파악 후 불필요한 기능이나 중복되는 기능이 있는지 확인 
- 행위 순서 규정 : 가용자가 특정기능을 사용하기 위한 행위 순서를 세분화시켜 순서대로 제시하고, 사용자가 임의로 행위 순서를 변경할 수 있도록 한다. 
- 행위의 순서대로 실행 : 프로세스의 흐름을 직접적으로 파악할 수 있도록 제공함으로써 사용자가 행위 순서대로 실행할 때 어려움이 없어야 한다.

3. 평가차를 줄이기 위한 UI 설계원리 검터

- 수행한 키 조작의 결과를 사용자가 빠르게 지각하도록 유도
- 키 조작으로 변화된 시스템의 상태를 사용자가 쉽게 인지하도록 유도
- 사용자가 가진 원래 의도와 시스템 결과 간의 유사 정도를 사용자가 쉽게 파악하도록 유도

### 👏 018 UI 상세 설계

1. UI 시나리오 문서 개요

- UI 상세 설계를 할 때는 반드시 시나리오를 작성해야한다. 
- UI 시나리오 문서는 사용자 인터페이스의 기능 구조, 대표화면, 화면간 인터랙션의 흐름, 다양한 상황에서의 예외 처리 등을 문서로 정리한 것이다. 
- UI 설계자 또는 인터랙션 디자이너가  UI 시나리오 문서를 작성하면 그래픽 디자이너가 시나리오를 바탕으로 디자인을 하고 개발자가 UI를 구현한다. 

2. UI  시나리오 문서 작성 원칙

- 개발자가 전체적인 UI의 기능과 작동 방식을 한눈에 이해할 수 있도록 구체적으로 작성한다. 보통 계층 구조 또는 플로차트 표기법으로 작성한다.
- 인터랙션의 흐름을 정의하며, 화면간 인터랙션의 순서, 분기, 조건, 루프 등을 명시한다. 
- 예외 상황을 대비한 다양한 케이스를 정의한다. 
- UI 일반 규칙을 지키면서 기능별 상세 기능 시나리오를 정의한다. 
- UI 시나리오 규칙을 지정한다. 

3. UI 시나리오 문서의 요건
- 완전성 : 누락되지 않도록 최대한 상세하게 기술
- 일관성 
- 이해성 : 누구나 쉽게 이해할 수 있도록 설명 
- 가독성
- 수정 용이성
- 추적 용이성

4. UI 시나리오 문서로 인한 기대 효과

- 오류 감소
- 개발 과정에서의 재작업이 감소하고, 혼선이 최소화된다. 
- 불필요한 기능을 최소화 한다.
- 개발 비용을 절감
- 개발 속도를 향상 

### 👏 019 HCI / UX / 감성공학

1. HCI : 원래 사람과 컴퓨터의 상호작용을 연구해 사람이 컴퓨터를 편리하게 사용하도록 만드는 학문이었으나, 대상이 컴퓨터 뿐 아니라 서비스, 디지털 콘텐츠 등으로, 사람도 개인뿐 아니라 사회나 집단으로 확대되었다.

2. UX : 사용자가 참여, 사용, 관찰하고, 상호 교감을 통해 알 수 있는 가치 있는 경험을 말함

- 특징 : 주관성, 정황성, 총체성 

3. 감성공학 : 사용자의 감성에 알맞도록 설계 및 제작하는 기술

- 감성공학의 요소기술 : 기반 기술, 구현 기술, 응용 기술 

## 📚 3장 : 애플리케이션 설계

### 👏 020 소프트웨어 아키텍처 
- 소프트웨어 개발 시 적용되는 원칙과 지침이다.
- 애플리케이션의 분활 방법과 분할된 모듈에 할당될 기능 등을 결정한다. 
- 소프트웨어 아키텍처 설계의 기본원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다. 

1. 모듈화 

- 모듈화란 소프트웨어의  성능을 향상시키거나 시스템의 수정 및 재사용, 유지관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미함
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고
- 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.

2. 추상화 

- 추상화는 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다. 
- 추상화는 최소의 비용으로 실제상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다. 
> - 추상화의 유형 
>   1. 과정 추상화 : 전반적인 흐름만 파악할 수 있게 설계
>   2. 데이터 추상화 : 데이터 구조를 대표할 수 있는 표현으로 대체
>   3. 제어 추상화 : 이벤트 발생의 절차나 방법을 정의하지 않고 대표할 수 있는 표현으로 대체

3. 단계적 분해

- 단계적 분해는 하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다. 
- 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다. 

4. 정보은닉

- 정보 은닉은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다. 
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다. 

5. 소프트웨어 아키텍처의 품질 속성

- 소프트웨어 아키텍처가 이해관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계 되었는지를 확인하기 위해 품질 평가 요소들을 시스템 측면, 비지니스 측면, 아키텍처 측면으로 구문하여 구체화시켜 놓은 것이다. 

> 1. 시스템 측면(어떤 속성이 어떤 측면에 속하는지 중요)
> - 성능 : 상요자의 요청이 발생했을 때 적절하고 빠르게 처리하는 것
> - 가용성 : 장애 없이 정상적으로 서비스를 제공
> - 기능성 : 사용자가 요구한 기능을 만족스럽게 구현하는 것
> - 사용성 : 사용자가 소프트웨어를 사용하는데 헤매지 않도록 명확, 편리하게 구현하는 것

> 2. 비지니스 측면
> - 시장 적시성 : 정해진 시간에 맞춰 프로그램을 출시하는 것
> - 비용과 혜택 : 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 결정하는 것, 유연성이 떨어지는 경우 유지보수에 많은 비용이 소모될 수 있다는 것을 고려해야 한다. 

> 3. 아키텍처 측면
> - 개념적 무결성 : 시스템을 이루는 구성요소들 간의 일관성을 유지
> - 정확성, 완결성 : 요구사항과 제약사항들을 모두 충족
> - 구축 가능성 : 모듈 단위로 구분된 시스템을 적적하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것

6. 소프트웨어 아키텍처의 설계 과정 

>  설계 목표 설정 ➡ 시스템 타입 결정 ➡ 아키텍처 패턴 적용 ➡ 서브시스템 구체화 ➡ 검토
- 시스템 타입
> - 대화형 시스템 : 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템
> - 이벤트 중심 시스템 : 외부의 상태 변화에 따라 동작하는 시스템
> - 변화형 시스템 : 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템
> - 객체 영속형 시스템 : 데이터베이스를 사용하여 파일을 효과적으로 저장,검색,갱신할 수 있는 시스템


### 👏 021 아키텍처 패턴
- 아키텍처 패턴은 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다. 
- 아키텍처 스타일, 표준 아키텍처라고도 한다. 
- 종류 : 레이어, 클라리언트-서버, 파이프-필터, 모델-뷰-컨트롤러 등

> **아키텍처 패턴의 장점**
> - 시행착오를 줄여 개발시간을 단축, 고품질의 소프트웨어를 생산
> - 검증된 구조로 개발하기 때문에 안정적인 개발이 가능
> - 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해짐
> - 구조를 이해하는 것이 쉬움
> - 시스템 특성을 개발 전에 예측하는 것이 가능

1. 레이어 패턴

- 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법
- 레이어 패턴은 서로 마주보는 두 개의 계측 사이에서만 상호작용이 이뤄지며, 변경 사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이하다. 
- 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다. 
- 대표적으로 OSI 참조 모델이 있다. 


2. 클라이언트-서버 패턴 

- 하나의 서버 컴포넌트와 다수 클라이언트 컴포넌트로 구성되는 패턴이다. 
- 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다. 
- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다. 

3. 파이프-필터 패턴

- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다. 
- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이하다.
- 파이트-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다. 
- 대표적으로 UNIX의 쉘이 있다. 

4. 모델 뷰 컨트롤러 패턴

- 모델-뷰-컨트롤러 패턴은 서브시스템을 3개의 부분으로 구조화하는 패턴
> 모델 : 서브시스템의 핵심 기능과 데이터를 보관한다.
> 뷰 : 사용자에게 정보를 표시한다.
> 컨트롤러 : 사용자로부터 받은 입력을 처리한다. 

- 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다. 

5. 기타 패턴 
> 1. 마스터-슬레이브 패턴 
> - 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서 처리된 결과무를 다시 돌려받는 방식으로 작업을 수행(장애 허용 시스템과 병렬 컴퓨팅 시스템에서 활용됨.)
> 2. 브로커 패턴 
> - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해준다. (분산 환경 시스템에서 주로 활용됨)
> 3. 피어 투 피어 패턴 (1대1관계)
> - 피어를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
> 4. 이벤트-버스 패턴
> - 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식이다. 
> 5. 블랙보드 패턴 
> - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다. 
> 6. 인터프리터 패턴
> - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된다. 
> - 특정 언어로 작성된 프로그램  코드를 해석하는 컴포넌트를 설계할 때 사용되어진다. 


### 👏 022 객체지향
- 객체지향은 현실세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법을 말한다. 
- 객체지향 기법은 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다. 
- 객체지향은 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다. 

1. 객체 : 객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈이다. 
    > - 데이터 : 객체가 가지고 있는 정보로 속성이나 상태 등을 나타내냄
    > - 함수 : 객체가 갖는 데이터를 처리하는 알고리즘

- 객체의 특성 
  > - 객체는 독립적으로 식별 가능한 이름을 가지고 있다. 
  > - 상태는 시간에 따라 변한다. 
  > - 객체와 객체는 상호 연관성에 의한 관계가 형성된다. 
  > - 객체가 반응할 수 있는 메시지의 집합을 행위라 하며, 객체는 행위의 특징을 나타낼 수 있다.
  > - 객체는 일정한 기억장소를 가지고 있다. 

- 객체의 매소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다. 


2. 클래스 
- 클래스는 공통된 속성과 연산을 갖는 객체의 집합
- 클래스에 속한 각각의 객체를 인스턴스라고 하며, 클래스로부터 새로운 객체를 생성하는 것을 신스턴스화라고 한다. 
- 슈퍼클래스는 특정 클래스의 상위클래스고, 서브 클래스는 특정 클래스의 하위 클래스를 의미한다. 

3. 캡슐화 

- 캡슐화는 데이터와 데이터를 처리하는 함수를 하나로 붂는 것을 의미한다. 
- 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다. 
- 캡슐화된 객체들은 재사용이 용이하다. 
- 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다. 

4. 상속 

- 상속은 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다. 
- 상위 클래스의 속성과 연산을  하위 클래스가 사용할 수 있기 때문에 객체과 클래스의 재사용, 즉 소프트웨어의 재사용을 높이는 중요한 개념이다. 
- 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것이다.

5. 다형성 
- 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다. 
- 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것이다. 

### 👏 023 모듈

- 모듈은 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다. 
- 모듈은 단독으로 컴파일이 가능하며, 재사용 할 수 있다. 
- 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이뤄진다. 
- 모듈의 독립성은 결합도와 응집도에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게 모듈의 크기는 작게 해야한다. 

1. 결합도

- 결합도는 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다. 
- **결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다**. 

>결합도 약함 ➡➡➡➡➡➡➡➡➡➡➡➡➡결합도 강함
>자료 ➡ 스탬프 ➡ 제어 ➡ 외부 ➡ 공통 ➡ 내용 (자스제외공내)

> **결합도의 종류**
> 1. 자료결합도 
> - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도이다. 
> - 모듈 간의 내용을 전혀 알 필요가 없는 상태로서 한 모듈의 내용을 변경하더라도 다른 모듈에는 전혀 영향을 미치지 않는 가장 바람직한 결합도다.
> 2. 스탬프 결합도 
> - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.
> - 두 모듈이 동일한 자료 구조를 조화하는 경우의 결합도
> 3. 제어 결합도
> - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어요소를 전달하는 결합도
> - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상이 발생하게 된다. 
> 4. 외부 결합도 
> - 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도이다.
> 5. 공통 결합도
> - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다. 
> - 공통 데이터 영역의 내용을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 만든다. 
> 6. 내용 결합도 
> - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다. 
> - 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당된다. 

2. 응집도 

- 응집도는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미한다. 
- **응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다**.

>응집도 강함  ➡➡➡➡➡➡➡➡➡➡➡➡➡➡➡➡➡➡➡ 응집도 약함(기술교절시논우/FSCPTL)
>기능적 ➡ 순차적 ➡ 교환적 ➡ 절차적 ➡ 시간적 ➡ 논리적 ➡ 우연적 

3. 팬인/팬아웃

- 팬인은 어떤 모듈을 제어하는 모듈의 수를 나타낸다. 
- 팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수를 나타낸다. 
- 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야 한다.


### 👏 024 공통 모듈C

- 공통 모듈은 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미한다. 
- 공통 모듈은 구현할 때는 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 다음의 명세 기법을 준수해야한다. 

> - 정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
> - 명확성 : 중의적으로 해석되지 않도록 명확하게 작성한다. 
> - 완전성 : 시스템 구현을 위해 필요한 모든 것ㅇ르 기술한다. 
> - 일관성 : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성한다.
> - 추적성 : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

1.  재사용 

- 재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야 한다. 

> **재사용 규모에 따른 분류**
> - 함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용한다. 
> - 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용한다. 
> - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용한다. 

2. 효과적인 모듈 설계 방안

- 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다. 
- 복잡도와 중복성을 줄이고 일관성을 유지시킨다. 
- 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.
- 하나의 입구와 하나의 출구를 갖도록 해야 한다. 
- 모듈의 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다. 

### 👏 025 코드

- 코드는 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호이다. 
- 일정한 규칙에 따라 작성된다. 

> **코드의 주요 기능**
> - 식별 기능 
> - 분류 기능 
> - 배열 기능 

1. 코드의 종류 
> - 순차코드 : 발생순서, 크기 순서 등 일정 기준에 따라서
> - 블록코드 : 공통성이 있는 것끼리 블록으로 구분, 쿠분코드라고도 함
> - 10진 코드 : 10진 분할하는 방법을 필요한 만큼 반복
> - 그룹 분류 코드 : 대분류, 중분류, 소분류 등으로 구분
> - 연상코드 : 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여
> - 표의 숫자 코드: 물리적 수치를 코드에 적용시킴
> - 합성코드 : 2개 이상의 코드를 조합하여 만드는 방법

2. 코드 부여 체계 

- 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식을 말한다. 
- 코드를 부여하기 전, 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 한다. 
- 코드 부여 체계를 담당하는 자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야 한다. 


### 👏 026 디자인 패턴 
- 디자인 패턴은 GoF가 처음으로 체계화 함
- Gof의 디자인 패턴은 유형에 따라 생성 패턴, 구조 패턴, 행위 패턴 총 23개의 패턴으로 구성
> **아키텍처 패턴 VS 디지인 패턴**
> - 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용됨
> - 아키텍처 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델이다. 

1. 생성 패턴

> 1. 추상 팩토리 : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 의존하는 객체들의 그룹을 생성하여 추상적으로 표현 한 것. 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다.
> 2. 빌더 : 작게 분리된 인스턴스를 건축하듯 조합하여 객체를 생성. 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다. 
> 3. 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다. 상위 클레스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다. 
> 4. 프로토타입 : 원본 객체를 복제하는 방법으로 객체를 생성
> 5. 싱글톤 : 클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비를 최소화 할 수 있다. 

2. 구조 패턴 : 구조 패턴은 복잡한 시스템을 개발하기 쉽게 도와준다. 
   
> 1. 어댑터 : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해줌
> 2. 브리지 : 서로 독립적으로 확장할 수 있도록 구성한 패턴, 기능과 구현을 두 개의 별도 클래스로 구현
> 3. 컴포지트 : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
> 4. 데코레이터 : 능동적으로 기능을 확장가능, 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
> 5. 퍼싸드 : 복잡한 서브 클래스들을 피해 더 상위 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 Wrapper 객체가 필요
> 6. 플라이웨이트 : 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴이다. 
> 7. 프록시 : 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴. 네트워크 연결, 대용량 객체로의 접근 등에 주로 이용한다. 


3. 행위 패턴

> 1. 책임 연쇄 : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다. 
> 2. 커맨드 : 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화
> 3. 인터프리터 : 언어에 문법 표현을 정의하는 패턴이다. SQL이나 통신 프로토콜 같은 것을 개발할 때 사용
> 4. 반복자 : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴(순차적 접근 가능)
> 5. 중재자 : 수많은 객체들 간의 복잡한 상호작용을 캡슐화함. 객체 사이의 의존성을 줄여 결합도를 감소
> 6. 메멘토 : 해당 시점의 상태로 돌릴 수 있는 기능
> 7. 옵서버 : 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴. 주로 분산시스템에 이용
> 8. 상태 : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
> 9. 전략 : 개별적으로 캡슐홥. 클러이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능하다. 
> 10. 템플릿 메소드 : 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부처리를 구체화하는 구조의 패턴. 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌
> 11. 방문자 : 분리된 처리 기능은 클래스를 방문하여 수행한다. 

## 📚 4장 : 인터페이스 설계
### 👏 027 시스템 인터페이스 요구사항 분석

1. 요구사항 명세서 

> (1) 인터페이스 이름
> (2) 연계 대상 시스템
> (3) 연계 범위 및 내용
> (4) 송신 데이터
> (5) 연계 방식
> (6) 인터페이스 주기 
> (7) 기타 고려사항 

2. 시스템 인터페이스 요구사항 분석 

- 소프트웨어 요구사항 분석 기법을 적절히 이용
- 분해가 필요한 경우 적절한 수준으로 세분화
- 누락된 요구사항이나 제한조건을 추가
- 상대적 중요도를 평가하여 우선순위를 부여


3. 시스템 인터페이스 요구사항 분석 절차 

> (1) 목록생성
> (2) 자료 준비
> (3) 기능/비기능 분류
> (4) 추가/수정
> (5) 이해관계자에게 전달 

### 👏 028 인터페이스 요구사항 검증
- 요구사항 검증 순서 
> 요구사항 검토 계획 수립 ➡ 검토 및 오류 수정 ➡ 베이스라인 설정


1. 요구사항 검토 계획 수립 

> - 검토 기준 및 방법을 정한다. 
> - 요구사항 검토 참여자를 선정한다. 
> - 검토 체크리스트를 작성한다.
> - 인터페이스 요구사항 검토에 필요한 자료들을 준비한다. 
> - 요구사항 검토 일정을 정한다. 

2. 요구사항 검토 및 오류 수정 

> - 검토 시 오류가 발견되면 오류를 수정할 수 있도록 오류 목록과 시정 조치서를 작성
> - 검토 결과를 검토 관련자들에게 전달한다. 
> - 시정 저치가 완료되면 인터페이스 요구사항 검토 작업을 완료한다. 

3. 요구사항 베이스라인 설정 

> - 관리자와 의사결정자에게 공식적으로 승인 받는다. 
> - 요구사항 명세서의 베이스라인을 설정한다. 

4. 요구사항 검증 방법

> (1) 테스트 설계 : 테스트 케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지 검토
> (2) 프로토타이핑 : 견본품을 만들어 최종 결과물을 예측
> (3) CASE 도구 활용 : 일관성분석을 통해 요구사항의 추적, 분석, 관리, 표준준수여부 확인
> (4) 요구사항 검토 
>   - 동료검토 : 작성자가 직접 설명, 동료들이 이를 들으며 결함을 발견
>   - 워크스루 : 요구사항 명세서를 사전 검토한 후 짧은 검토회의롤 통해 결함을 발견
>   - 인스펙션 : 작성자를 제외한 다른 전문가들이 결함을 발견 

5. 인터페이스 요구사항 검증의 주요 항목

- 완전성 
- 일관성
- 명확성
- 기능성
- 검증 가능성
- 추적 가능성
- 변경 용이성 

### 👏 029 인터페이스 시스템 식별 C

1. 개발 시스템 식별 (내부)

- 개발 시스템을 식별하는 것은 시스템의 상세 식별 정보를 정의하고 목록을 작성하는 것이다. 

2. 내, 외부 시스템 식별 

- 내, 외부 시스템들의 상세 식별 정보를 정의하고 목록을 작성하는 것이다. 


### 👏 030 송,수신 데이터 식별 C

1. 식별 대상 데이터 : 송, 수신 시스템 사이에서 교환되는 데이터
> **종류**
> - 인터페이스 표준 항목 : 송 ,수신 시스템을 연계하는데 표준적으로 필요한 데이터(시스템 공통부와 거래 공통부로 나뉜다.)
> - 송, 수신 데이터 항목
> - 공통 코드

### 👏 031 인터페이스 방법 명세화

1. 시스템 연계 기술 
- DB Link
- API/Open API
- 연계 솔루션
- Socket
- Web Servise

2. 인터페이스 통신 유형 

- 단방향 : 거래요청만 하고 응답이 없음
- 동기 : 거래를 요청하고 응답이 올 때까지 대기 
- 비동기 : 시스템에서 거래를 요청하고 다른 작업을 수행하다 응답이 오면 처리

3. 인터페이스 처리 유형 

- 실시간 방식
- 지연 처리 방식 : 비용 많을 때 사용 
- 배치 방식 : 대량의 데이터 처리할 때 사용

4. 인터페이스 발생 주기 

- 업무의 성격과 데이터 전송량을 고려해 매일, 수시, 주 1회 등으로 구분

5. 오류 식별 및 처리 방안 명세화 

- 다양한 오류 상황을 식별하고 분류한다. 
- 오류 상황에 대해 오류코드, 오류 메시지, 오류 설명, 해결 방법 등을 명세화한다. 

### 👏 032 시스템 인터페이스 설계서 작성 C

1. 시스템 인터페이스 목록 작성 

- 시스템 인터페이스 목록에는 연계 업무와 연계에 참여하는 송,수신 시스템의 정보, 연계 방식과 통신 유형 등에 대한 정보를 기록한다. 

2. 시스템 인터페이스 정의서 작성

- 인터페이스별로 시스템 간의 연계를 위해 필요한 테이터 항목 및 구현 요건 등을 기술한다.

### 👏 033 미들웨어 솔루션 명세 
- 미들웨어의 개념 및 종류

> - 미들웨어는 표준화된 인터페이스를 제공하여 시스템 간의 데이터 교환에 일관성을 보장
> - 미들웨어는 통신 제공 방법이나 기능에 따라 DB, RPC, MOM...등으로 구분

1. DB(DataBase)
> - 데이터베이스와 연결하기 위한 미들웨어이다. 
> - 2-Tier 아키텍처라고 한다. 
> - 종류 : ODBC, IDAPI, Glue

2. RPC(Remote Procedure Call)

> - 로컬 프로시저처럼 호출하는 방식의 미들웨어
> - 종류 : Entera, ONC/RPC

3. MOM(Message Oriented Middleware)

> - 메시지 기반의 비동기형 메시지를 전달하는 방식 
> - 종류 : MQ, Message Q, JMS 

4. TP-Monitor(Transaction Processing Monitor)

> - 온라인 트랜잭션 업무
> - 종류 : tuxedo, tmax

5. OBR(Object Request Broker)

> - 객체 지향 미들웨어
> - 종류 : Obrix, CORBA

6. WAS(Web Application Server)

> - 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어다. 
> - 종류 : WebLogic, WebSphere  

7. 미들웨어 솔루션 식별 

> - 식별한 미들웨어 솔루션들에 대해 솔루션의 시스템, 구분, 솔루션명, 버전, 제조사 등의 정보를 정리한 미들웨어 솔루션 목록을 작성한다. 


8. 미들웨어 솔루션 명세서 작성

> - 제품 안내서 및 설명 자료 등을 통해 검토
> - 설명 자료나 관련 담당자를 통해 검토
> - 환경 구성, 제공 기능 등에 대한 제약사항이 존재하는지 제품 안내서 및 기술 지원 담당자를 통해 검토한다. 
> - 제약사항을 정리하여 솔루션에 대한 명세서를 작성한다. 


