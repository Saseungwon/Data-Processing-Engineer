

## 3회 1과목
### 1. CASE(Computer-Aided Software Engineering)

**(1) CASE란?**
- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용의 소프트웨어 도구를 사용하여 자동화
- 표준화된 개발 환경 구축 및 문서 자동화 기능을 제공
- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대
- 이점
  - 개발을 신속하게 할 수 있다.
  - 오류 수정이 쉬워 S/W 품질이 향상된다.
  - S/W개발 단계의 표준화를 기할 수 있다.
- CASE 분류
    - 상위 CASE
      - 모델들 사이의 모순검사 가능
      - 모델의 오류검증 기능
      - 자료흐름도 작성 기능
    - CASE 도구의 정보저장소(Repository)
      - 일반적으로 정보저장소는 도구들과 생명주기 활동, 사용자들, 응용 소프트웨어들 사이의 통신과 소프트웨어 시스템 정보의 공유를 향상시킨다.
      - 초기의 소프트웨어 개발 환경에서는 사람이 정보저장소 역할을 했지만 오늘날에는 응용 프로그램이 정보저장소 역할을 담당한다.
      - 소프트웨어 시스템 구성 요소들과 시스템 정보가 정보저장소에 의해 관리되므로 소프트웨어 시스템의 유지보수가 용이해진다.
  
**(2) CASE의 주요 기능**
  - 그래픽 지원
  - 소프트웨어 생명주기(Software Lifecycle) 전 단계의 연결
  - 다양한 소프트웨어 개발 모형 지원



### 2. 시퀀스 다이어그램(Squence Diagram)

- 어떠한 순서로 어떤 객체들과 어떻게 상호작용을 했는지 표현하는 다이어그램
- 세부요소

    - 생명선 : 모델링 되는 개개의 인스턴스를 나타냄

    - 실행 : 인스턴스가 실제로 다른 인스턴스와 상호작용을 하며 활성화되어있는 것을 나타냄

  -   메시지 : 인스턴스간의 주고받는 데이터


### 3. 디자인패턴

(1) 생성 패턴 (Creational Pattern)

● Factory Method 패턴 

- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴

- 상위 클래스에서 인터페이스만 정의하고 실제 생성을 서브 클래스가 담당

 

(2) 구조 패턴 (Structural Pattern)

● Bridge 패턴

- 구현부에서 추상층을 분리하여, 서로 독립적으로 확장 가능하게 구성한 패턴

- 기능과 구련을 두 개의 별도 클래스로 구현

 

(3) 행위 패턴 (Behavioral Pattern)

● Visitor 패턴

- 각 클래스들이 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

- 분리된 처리 기능은 각 클래스를 방문visit 하여 수행

 

● Observer 패턴

- 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴

- 주로 분산된 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야할 때 이용

### 4. 미들웨어
미들웨어(Middleware)

운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적으로 서비스를 제공하는 소프트 웨어

● DB(DataBase) : 데이터베이스 벤더에서 제공하는 크라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어

● RPC(Romote Procedure Call) : 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미둘웨어

● MOM(Message Oriented Middleware) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어

● TP-Monitor(Trasaction Processing Monitor) : 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어

● ORB(Object Request Broker) :객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 수현하는 미들웨어

● WAS(Web Application Server) : 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 위해 사용되는 미들웨어


![screensh](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOIdVs%2FbtqG7SIfYxJ%2FuqIk96IprxjgAbclc6Wzg1%2Fimg.jpg
)

### 5. UML 다이어그램 종류

**구조적(Structural) 다이어그램**	
- 클래스(Class) 다이어그램
- 객체(Object) 다이어그램
- 컴포넌트(Component) 다이어그램
- 배치(Deployment) 다이어그램
- 복합체 구조(Composite) 다이어그램
- 패키지(Package) 다이어그램	

**행위(Behavioral) 다이어그램**
- 유스케이스(Use Case) 다이어그램
- 시퀀스(Sequence) 다이어그램
- 커뮤니케이션(Communucation) 다이어그램
- 상태(State) 다이어그램
- 활동(Activity) 다이어그램
- 상호작용 개요(Interaction Overview) 다이어그램
- 타이밍(Timing) 다이어그램 


### 6. 자료사전 기호

● { } : 자료의 반복

● ** : 자료의 설명(주석)

● = : 자료의 정의

● ( ) : 자료의 생략

● + : 자료의 연결

● [ | ] : 자료의 선택 (A or B) 

### 7. 객체지향 설계 5대 원칙

● SRP (Single Responsibility Principle) : 모든 클래스는 각각 하나의 책임만 가져야함. 클래스는 그 책임을 캡슐화애햐함.

● OCP (Open Closed Principle) : 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야함.

● LSP (Liskow Substitution Principle) : 자식 클래스는 언제나 부모 클래스를 대체가능 할 수 있어야함.

● ISP (Interface Segregation Principle) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야함. 

● DIP (Dependendy Inversion Principle) : 변화하기 쉬운 것 보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존해야함.

### 8. 자료 흐름도 구성요소

● process : 자료를 변환 시키는 시스템의 한 부분. (=처리, 기능, 변환, 버블) / 원

● data flow : 자료의 이동을 나타냄 / 화살표

● data store : 시스템에서의 자료 저장소 / 삼각형

● terminator : 시스템과 교신하는 외부 객체. 입력 데이터가 만들어지로 출력데이터를 받음 / 사각형

## 3회 2과목

### 1. 인터페이스 보안 - 네트워크 영역

● IPsec : 네트워크 층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜

● SSL : TCP/IP 계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜

● S-HTTP : 클라이언트와 서버 간에 전송되는 모든 메시지를 암호화 하는 프로토콜

 
- 오답 : SMPT : 타인에게 메일을 보낼 때 그 매일은 SMPT로 전송 > SMPT서버에서 프로그램을 구동하여 해당 메일 주소로 이메일을 보냄


### 2. 제어흐름 그래프 McCabe cyclomatic 수 계산 
![screensh](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FePOJ8Q%2FbtqIXknKtZU%2F6sqY9GD0HQ2Eor47iaCky0%2Fimg.png
)
![screensh](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTmDbs%2FbtqIN984rTa%2Fw60kKQubFizlN8sz3g8Ds1%2Fimg.png
)
V = E(Edge) - N(Node) + 2

6-4+2 = 4

### 3. 정렬 정리(선택, 버블, 삽입)