# ‍🏄‍♂️ 정보처리기사 자격증 

# 🐳 2과목 : 소프트웨어 개발

## 📚 1장 : 데이터 입,출력 구현

### 034 자료 구조

#### 1.  자료구조의 정의 

> - 일련의 자료들을 조직하고 구조화하는 것
> - 필요한 모든 연산들을 처리할 수 있다. 
> - 자료 구조에 따라 프로그램 실행시간이 달라진다. 

#### 2. 자료 구조의 분류 

- 선형구조(순서O)
> - 배열 
> - 선형리스트(연속리스트, 연결리스트)
> - 스택
> - 큐
> - 데크

- 비선형구조(순서X)
> - 트리

#### 3. 배열
> - 동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합이다. 
> - 첨자를 이용하여 데이터에 접근
> - 반복적인 데이터 처리에 적합한 구조
> -  데이터마다 동일한 이름의 변수를 사용해 처리가 간편
> - 사용한 첨자의 개수에 따라 n차원 배열이라고 부름

#### 4. 선형 리스트 
- 연속 리스트 
> - 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다. 
> - 기억장소 이용 효율이 가장 좋다. 
> - 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입 삭제 시 자료의 이동이 필요하다.(단점)
- 연결 리스트
> - 노드의 포인터 부분을 이용하여 서로 연결시킨 자료구조 
> - 노드의 삽입, 삭제 작업이 용이
> - 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다. 
> - 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다. 
> - 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다. 

#### 5. 스택
> - 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조
> - 후입선출 방식
> - 기억 공간이 꽉 채워져 있으면 오버플로가 발생, 삭제할 데이터가 없으면 언더플로 발생

#### 6. 큐
> - 한쪽에서는 삽입 작업이, 한쪽에서는 삭제 작업이 이뤄지는 자료구조
> - 선입선출 방식
> - 프런트 포인터 : 삭제 
> - 리어 포인터 : 삽입

#### 7. 트리 
- 트리 관련 용어

> - 노드 : 트리의 기본 요소  // ABCDEFGHIJKLM
> - 근 노드 : 트리의 맨 위에 있는 노드 // A
> - 디그리 : 각 노드에서 뻗어 나온 가지의 수 // A = 3
> - 단말 노드 = 잎 노드 : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드 // KLM
> - 자식 노드 : 어떤 노드에 연결된 다음 레벨의 노드들
> - 부모 노드 
> - 형제 노드 : 동일한 부모를 갖는 노드 
> - 트리의 디그리 : 노드들의 디그리 중 가장 많은 수 // 3  


### 035 데이터저장소/데이터베이스/DBMS

#### 1. 데이터 저장소 
- 데이터저장소는 논리데이터저장소와 물리 데이터저장소로 구분
> - 논리 데이터저장소는 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것을 의미
> - 물리 데이터저장소는 소프트웨어가 운용될 환경의 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장한 것을 의미 

#### 2. DBMS
- DBMS : 데이터베이스를 관리해주는 소프트웨어
> - 정의 기능 : 정의, 이용 방식, 제약 조건 등을 명시하는 기능
> - 조작 기능 : 데이터 검색, 갱신, 삽입, 삭제 
> - 제어 기능 : 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안을 유지하고 권한을 검사할 수 있어야 한다. 여러 사용자가 데이터베이스를 동시에 접근할 때도 정확성을 유지하도록 **병행 제어**를 할 수 있어야 함

#### 3. DBMS의 장단점
- 장점
> - 데이터의 논리적, 물리적 독립성이 보장됨
> - 데이터의 중복을 피할 수 있어 기억 공간이 절약됨
> - 자료를 공동으로 이용할 수 있음
> - 데이터의 일관성 유지
> - 데이터의 무결성 유지 
> - 보안 유지 가능
> - 데이터의 표준화
> - 데이터를 통합하여 관리
> - 항상 최신 데이터 유지가능
> - 데이터의 실시간 처리 가능
- 단점 
> - 전문가가 부족
> - 전산화 비용 증가
> - 대용량이라 과부화 발생
> - 백업과 리커버리가 어려움
> - 시스템이 복잡 


### 036. 데이터 입,출력 

#### 1. 데이터 입출력의 개요 

- 데이터 입출력은 데이터를 조작하는 모든 행위를 의미, 이와 같은 작업을 위해 SQL을 사용
- 데이터 접속 : 객체와 데이터를 연결하는 것
- 트랜잭션 : 수행되어야 할 인련의 연산들

#### 2. SQL 

- 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분됨

> - 데이터 정의어(DDL) : 정의, 변경, 삭제할 때 사용하는 언어
> - 데이터 조작어(DML) : 데이터를 실질적으로 처리하는 데 사용
> - 데이터 제어어(DCL) : 보안, 무결성, 회복, 병행, 수행제어 등을 정의할 때 사용

#### 3. 데이터 접속

- SQL Mapping : 프로그래밍 코드 내에 SQL을 직접 입력
- ORM : 객체지향 프로그래밍의 객체와 관계 데이터베이스의 데이터를 연결

#### 4. 트랜잭션 
- 논리적 기능들을 수행하기 위한 일련의 연산들을 의미
> - COMMIT : 데이터베이스에 반영하는 명령어
> - ROLLBACK : 이전 상태로 되돌리는 연산 
> - SAVEPOINT : 저장점을 지정하는 명령어 
### 037. 절차형 SQL 

#### 1. 절차형 SQL이란?

- 절차형 SQL은 연속적인 실행이나 반복 등의 제어가 가능한 SQL을 의미한다. 
> - 연속적인 작업들을 처리하는데 적합하다. 
> - BEGIN ~ END 형식으로 작성되는 블록 구조
> - 절차형 SQL의 종류
>   (1) 프로시저 : 미리 저장해 놓은 SQL 작업을 수행한다. 
>   (2) 트리거 : 데이터의 입력, 갱신, 삭제 등 이벤트가 발생할 때마다 작업이 자동수행됨
    (3) 사용자 정의 함수 :  종료 시 예약어 Return을 사용하여 처리 결과를 단일값으로 반환

#### 2. 절차형 SQL의 테스트와 디버깅
> - 절차형 SQL은 테스트 전에 구문 오류나 참조오류의 존재 여부를 확인한다.
> - SHOW 명령어를 통해 내용을 확인하고 문제를 수정한다. 
> - 디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인한다.  

#### 3. 쿼리 성능 최적화
- 쿼리 성능 최적화는 SQL코드를 최적화하는 것이다. 

> - APM을 사용하여 최적화 할 쿼리를 선정해야 한다. 
> - 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토한다. 

## 📚 2장 : 통합 구현 

### 038. 단위 모듈 구현 

#### 1. 단위 모듈이란? 
- 단위 모듈은 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다. 
- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다. 
- 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현할 수 있다. 
- 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있다. 

#### 2. 단위 기능 명세서 작성
- 단위 기능 명세서는 기능 및 코드 명세서나 설계 지침과 같이 단위 기능을 명세화한 문서들을 의미함. 
- 추상화 작업이 필요하다. 
- 구조화 과정을 거친다. 
- 정보 은닉(다른 모듈이 접근하거나 변경하지 못하도록 하는 것)의 원리를 고려한다. 

#### 3. 입출력 기능 구현 
- 입출력 기능을 위한 알고리즘 및 데이터를 구현한다. 
- CLI(키보드를 통해 명령어 입력 받음), GUI(MS의 아이콘 같은 거) 와의 연동을 고려함 
- 오픈소스 API를 이용하면 간편하게 구현 가능 

#### 4. 알고리즘 구현
- 디바이스 드라이버 모듈 : 하드웨어 주변 장치의 동작을 구현한 모듈 
- 네트워크 모듈 : 데이터 통신을 위한 기능
- 파일 모듈 : 컴퓨터 내부 데이터에 접근하는 방법을 구현한 모듈
- 메모리 모듈 : 통신 기능을 구현한 모듈 
- 프로세스 모듈 : 하나의 프로세스 안에서 다른 프로세서를 생성하는 방법을 구현한 모듈

#### . IPC
- IPC는 모듈 간 통신 방식을 구현하기  위해 사용되는  대표적인 프로그래밍 인터페이스 집합이다. 
- 프로세스 간 통신까지 구현이 가능합니다. 
- 종류 
    > - Shared Memory
    > - Socket
    > - Semaphores
    > - Pipes&named Pipes
    > - Message Queueing


### 039. 단위 모듈 테스트 
#### 1. 단위 모듈 테스트의 개요 
- 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것
- 화이트박스 테스트(모든 논리적인 경로를 테스트) / 블랙박스 테스트 기법을(특정기능이 작동되나 테스트) 사용 
- 모듈 통합 후엔 오랜 시간 추적해야하지만 단위 모듈 테스트를 수행하면 쉽게 발견하고 수정할 수 있다.
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다. 

#### 2. 테스트 케이스 

- 단위 모듈은 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스를 만든다. 
- 표준에 따른 테스트 케이스의 구성요소는 다음과 같다.

    > - 식별자 
    > - 테스트 항목
    > - 입력 명세
    > - 출력 명세
    > - 환경 설정
    > - 특수 절차 요구
    > - 의존성 기술

#### 3. 테스트 프로세스 
- 테스트 프로세스 5단계

> **1. 계획 및 제어 단계** 
> **2. 분석 및 설계 단계** : 테스트 시나리오와 테스트 케이스를 작성
> **3. 구현 및 실현 단계** : 테스트 프로시저에 명세하는 단계, 단위 테스트 도구를 이용하여 테스트를 수행
> **4. 평가 단계** : 평가, 기록
> **5. 완료 단계** : 수행 과정과 산출물을 기록 및 저장하는 단계 


### 039. 개발 지원 도구 

#### 1. 통합 개발 환경 
- 통합 개발 환경 도구는 코드의 자동 생성 및 컴파일이 가능하다. 
- 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이
- 외부의 다양한 서비스와 연동하여 개발에 편의를 제공한다. 
- 이클립스, 비주얼 스튜디오, 엑스코드, 안드로이드 스튜디오, IDEA

#### 2. 빌드 도구
- 빌드 도구는 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어를 말한다. 
- 대표적인 도구 : **Ant, Maven, Gradle** 
> **1. Ant** 
>       - 자바의 공식적인 빌드 도구 
>       - XML 기반 
>       - 정해진 규칙이나 표준 없이 스크립트의 재사용 어려움
> **2. Maven** 
>       - 아파치 소프트웨어 재단에서 개발됨  
>       - 규칙이나 표준이 존재하여 예외 사항만 기록하면 됨
>       - 컴파일과 빌드를 동시에 수행할 수 있다. 
>       - 의존성을 설정하여 라이브러리를 관리함
> **3. Gradle** 
>       - 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구이다. 
>       - 안드로이드 스튜디오의 공식 빌드 도구
>       - Maven과 동일하게 의존성을 활용, 그루비 기반의 빌드 스크립트를 사용

#### 3. 기타 협업 도구

- 프로젝트 및 일정 관리 : 구글 캘린더, 지라, 플로우
- 정보 공유 및 커뮤니케이션 : 슬랙, 잔디, 태스트월드
- 디자인 : 스케치, 제플린
- 기타 : 에버노트, 스웨거, 깃허브 

## 📚 3장 : 제품 소프트웨어 패키징 

### 041. 소프트웨어 패키징 

#### 1. 소프트웨어 패키징이란?
- 소프트웨어 패키징이란 배포용 설치파일을 만드는 것이다.
> - 개발자가 아닌 사용자 중심으로 진행
> - 소스 코드는 향후 관리를 위해 모듈화 하여 패키징한다.
> - 다양한 환겨에서 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징
> - 사용자의 편의성 및 실행 환경을 우선적으로 고려

#### 2. 패키징 시 고려사항
>- 사용자의 시스템 환경, 운영체제 등 필요한 최소환경을 정의한다. 
>- UI는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 메뉴얼과 일치시켜 패키징한다.
>- 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
>- 안정적인 배표가 중요
>- 패키징의 변경 및 개선에 대한 관리를 항상 고려
#### 3. 패키징 작업 순서(기모빌 사적 변배)
> 1. 기능 식별 : 작성된 코드의 기능을 확인
> 2. 모듈화 : 코드들을 분류
> 3. 빌드 진행 : 모듈 단위별로 실행 파일을 만든다. 
> 4. 사용자 환경 분석 : 사용될 환경이나 최소 운영 환경을 정의한다. 
> 5. 패키징 및 적용 시험 : 배포용 파일 형식으로 패키징한다. 
> 6. 패키징 변경 개선 : 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선을 진행 
> 7. 배포 : 배포 수행 시 오류가 발생하면 해당 개발자에겍 전달하여 수정을 요청 

  ### 042. 릴리즈 노트 작성 

#### 1. 릴리즈 노트란?

- 릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서다. 
>- 릴리즈 노트를 통해 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인 가능함 
>- 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있다. 
>- 릴리즈 노트는 소프트웨어의 초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공한다. 

#### 2. 릴리즈 노트 "초기" 버전 작성 시 고려사항 
- 릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 **현재 시제로 작성**해야한다. 
- 신규 소스, 빌드 등의 이력이 정확하게 관리되어 **변경 또는 개선된 항목에 대한 이력 정보들도 작성**되어야 한다. 
- 일반적으로 포함되는 항목 

> - **머릿말** : 릴리즈 노트 이름, 소프트웨어 이름, 버전, 날짜 등 
> - **개요** : 변경사항 전체에 대한 간략한 내용 
> - **목적** : 해당 릴리즈 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적
> - **문제 요약** : 수정된 버그에 대한 간략한 설명, 릴리즈 추가 항목에 대한 요약 
> - **재현 항목** : 버그 발견에 대한 과정 설명
> - **수정/개선 내용** : 수정/개선한 내용
> - **사용자 영향도** : 해당 릴리즈 버전에서의 기능 변화가 미 칠수 있는 영향에 대한 설명
> - **SW 지원 영향도** : 해당 릴리즈 버전에서의 기능 변화가 다른 프로그램에 미칠 수 있는 영향
> - **노트** : SW/HW 설치 항목, 업그레이드에 대한 참고 항목
> - **면책 조항** : 회사 및 스포트웨어와 관련하여 참조할 사항 
> - **연락처**

#### 3. 릴리즈 노트 "추가" 버전 작성 시 고려사항

- 소프트웨어의 테스트 과정에서 배타 버전이 출시되거나 긴급한 버그 수정, 업그레이드, 사용자 요청 등의 특수한 상황이 발생하는 경우 릴리즈 노트를 추가로 작성한다. 
> **1. 중대한 오류가 발생하여 긴급 수정하는 경우** : 릴리즈 버전 출시하고 버그 번호를 포함한 모든 수정된 내용을 다아 릴리즈 노트를 작성한다.
> **2. 소프트웨어에 대한 기능 업그레이드를 완료한 경우** : 릴리즈 버전을 출시하고 릴리즈 노트를 작성한다.   
> **3. 사용자로부터 접수된 요구사항에 의해 추가나 수정된 경우** : 자체 기능 향상과는 다른 별도의 릴리즈 버전으로 출시하고 릴리즈 노트를 작성한다. 

#### 4. 릴리즈 노트 작성 순서 
> **1. 모듈 식별** : 작성될 내용들을 확인한다. 
> **2. 릴리즈 정보 확인** : 릴리즈 노트 이름. 날짜 등을 정리한다. 
> **3. 릴리즈 노트 개요 작성** : 소프트웨어 및 변경사항 전체에 대한 간략한 내용을 작성
> **4. 영향도 체크**  : 릴리즈 버전에서의 변화가 다른 소프트웨어나 기능에 미칠 수 있는 영향 기술
> **5. 정식 릴리즈 노트 작성** : 정식 릴리즈 노트에 작성될 기본 사항들을 작성
> **6. 추가 개선 항목 식별** : 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트를 작성


### 👏 043 디지털 저작권 관리(DRM)

#### 1. 디지털 저작권 관리란? 
- 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 관리,보호하는 기술
> - 원본 콘텐츠가 아날로그인 경우 디지털로 변환 후 DRM 패키징 수행
> - 콘텐츠의 크기에 따라 
>          **(1) 크기가 작은 경우** : 실시간으로 패키징 수행
>          **(2) 크기가 큰 경우** : 미리 패키징 수행 후 배포
> - 사람에 따라 
>           **(1) 저작권자** : 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스에 등록된다.
>           **(2) 사용자** : 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인 받아야 한다.

#### 2. 디지털 저작권 관리의 흐름도(P.200)
- **클리어링 하우스** : 저작권에 대한 사용권한, 라이선스 발급, 사용량에 따른 결제관리 등을 수행
- **콘텐츠 제공자** : 콘텐츠를 제공하는 저작권자
  - **패키저** : 콘텐츠 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- **콘텐츠 분배자** : 암호화된 콘텐츠를 유통하는 곳
- **콘텐츠 소비자** : 구매해서 사용하는 주체
  - **DRM 컨트롤러** : 배포된 콘텐츠의 이용권한을 통제
  - **보안 컨테이너** : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치 

#### 4. 디지털 저작권 관리의 기술 요소
- 사용되는 기술 
> - 암호화
> - 키관리
> - 암호화 파일 생성
> - 식별 기술
> - 저작권 표현
> - 정책 관리
> - 크랙 방지 : 무단으로 사용하게 하는 기술이나 도구를 방지
> - 인증 

### 👏 044 소프트웨어 설치 매뉴얼 작성

#### 1. 소프트웨어 설치 메뉴얼이란? 
- 소프트웨어 설치 매뉴얼은 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서이다. 

> - 사용자를 기준으로 작성
> - 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명
> - 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명 
> - 소프트웨어 설치 메뉴얼에는 목차 및 개요, 서문, 기본사항 등이 요약한 후 관련 내용의 시작 페이지를 함께 기술한다. 
> - 개요에는 설치 매뉴얼의 주요 특징, 구성과 설치 방법, 순서 등의 내용을 기술한다. 

#### 2. 서문 
- 서문에는 문서이력, 설치 메뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목을 기술한다. 
**1. 문서 이력** : 버전, 작성자, 작성일 ...
**2. 설치 매뉴얼의 주석** : 주의 사항과 참고 사항을 기술한다. 
**3. 설치 도구의 구성** : 설치 관련파일 / 폴더 및 설치 프로그램 실행 파일 / LOG 폴더에 대해 설명
**4. 설치 환경 체크 항목** : 사용자 환경 / 응용 프로그램 / 업그레이드 버전 / 백업 폴더 확인

#### 3. 기본 사항 
- 기본적으로 설명되어야 할 항목들은 다음과 같다. 
**1. 소프트웨어 개요** : 주요기능 및 UI, UI 및 화면 상의 버튼, 프래임 등을 그림으로 설명
**2. 설치 관련 파일** : 설치에 필요한 파일 설명 / exe, ini, log 등의 파일 설명
**3. 설치 아이콘**
**4. 프로그램 삭제**
**5. 관련 추가 정보**

#### 4. 설치 매뉴얼 작성 방법 
**1. 설치 화면 및 UI**
  - 설치 실행과 메인 화면 및 안내창에 대한 내용을 기술한다. 
  **(1) 설치 실행** : exe 등의 설치 파일을 실행할 수 있도록 실행 화면에 대한 이미지를 첨부하여 설명.
  **(2) 메인 화면 및 안내창** : 설치 시 나타나는 메인 화면과 각 과정에서의 안내창에 대한 이미지를 첨부하여 설명한다. 

**2. 설치 이상 메시지 설명**
 - 설치 방법이나 설치 환경이 잘못된 경우 표시될 수 있는 메시지에 대해 설명한다. 

**3. 설치 완료 및 결과**
- 설치가 정상적으로 마무리되었음을 사용자에게 최종적으로 알려준다. 

**4. FAQ** 
 - 설치 시 발생할 수 있는 다양한 상황을 FAQ로 정리하여 수록한다. 

**5. 설치 시 점검 사항**
- 설치에 필요한 사용자 계정 및 설치 권한에 대해 확인할 수 있도록 설명
- 설치 과정에서 오류가 발생한 경우 점검할 수 있는 사항들에 대해 설명 

**6. Netwoer 환경 및 보안**
- 네트워크 오류로 인해 설치 시 문제가 발생하지 않도록 사전에 필요한 네트워크 연결 상태를 점검하도록 안내
- 보안이나 방화벽으로 인해 설치 시 문제가 발생하지 않도록 관련된 내용을 안내


**7. 고객 지원 방법** 
- 문의할 수 있는 연락처를 안내

**8. 준수 정보 & 제한 보증**
- 사용 금지 등에 대한  준수사항을 안내
- 저작권자 소유권 정보 등과 관련된 내용을 안내

#### 5. 설치 매뉴얼 작성 순서 
> 1. 기능 식별 
> 2. UI분류
> 3. 설치 파일 / 백업 파일 확인
> 4. Uninstall 절차 확인
> 5. 이상 Case 확인
> 6. 최정 매뉴얼 적용

    
### 👏 045 소프트웨어 사용자 매뉴얼 작성(앞에 설치매뉴얼과 비교)

#### 1. 소프트웨어 사용자 매뉴얼의 개요 
- 사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성한다. 
- 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리한다. 
- 컴포넌트 단위로 매뉴얼을 작성한다. 
- 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설게서를 토대로 작성한다.
- 사용자 매뉴얼에는 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다. 


#### 2. 서문 
1. 문서이력 
2. 사용자 매뉴얼의 주석 : 주의사항과 참고 사항을 기술
3. 기록 보관 내용 
    - 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록 정보를 기술한다. 
    - 소프트웨어 명칭, 모델명, 문서 번호, 제품 번호, 구입 날짜

#### 3. 기본 사항
- 소프트웨어 개요 : 주요기능 및 UI 설명, 그림으로 설명
- 소프트웨어 사용 환경 : CPU, 메모리 등의 PC사양, 운영체제 버전 설명 / 소프트웨어 사용시 발생할 수 있는 프로그램 충돌이나 개인정보, 보안 등에 관한 주의사항을 설명한다
- 소프트웨어 관리 
- 모델, 버전별 특징
- 기능, 인터페이스의 특징
- 소프트웨어 구동 환경 : 개발에 사용한 언어 및 호환 가능한 운영체제에 대해 설명한다. 

#### 4. 사용자 매뉴얼 작성 방법 

>1. 사용자 화면 및 UI : 주의사항과 참고사항을 기술한다. 
    - 주의사항 : 소프트웨어를 사용할 때 사용자가 반드시 알고 있어야 하는 중요한 내용을 설명
    - 참고 사항 : 특별한 사용자의 환경이나 상황에 대한 내용을 설명한다.
>2. 주요 기능 분류 
    - 기능이 실행되는 화면을 순서대로 캡처하여 기능에 대한 사용법을 설명
>3. 응용 프로그램 및 설정
    - 소프트웨어 구동 시 함께 실행해도 되는 응용 프로그램, 또는 함께 실행되면 안 되는 응용 프로그램에 대해 설명한다. 
    - 소프트웨어가 정상적으로 구동되기 위한 설정이나 기본값에 대해 설명
>4. 장치 연동
    - 소프트웨어가 특정 장치에 내장되는 경우 연동 되는 장치에 대해 설명
>5. Network 환경
    -  Network에 접속되어 사용되는 소프트웨어인 경우 정상적인 연결을 위한 설정값 등을 설명
>6. Profile 안내
    - 사용자가 Profile의 경로를 변경하거나 위치를 이동하지 않도록 안내한다.
    - Profile과 같이 소프트웨어 구동에 필수적인 파일에 대해 설명한다. 
>7. 고객 지원 방법 
    - 연락처를 안내
>8. 준수 정보 & 제한 보증
    - 불법 등록 사용 금지, 지적 소유권 정보 등과 관련된 정보를 안내한다. 

#### 5. 사용자 매뉴얼 작성 순서

>1. 기능 식별
>2. 사용자 화면 분류
>3. 사용자 환경 파일 확인
>4. 초기화 절차 확인
>5. 이상 Case 확인 



### 👏 046 소프트웨어 버전 등록
#### 1. 소프트웨어 패키징의 형상 관리
- 형상 관리(SCM)은 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동이다.
> (1) 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 담당자에게 통보한다. 
> (2) 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행됨
> (3) 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다. 

#### 2. 형상 관리의 중요성
> - 지속적인 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있다.
> - 제품 소프트웨어에 대한 무절제한 변경을 방지할 수 있다. 
> - 발견된 버그나 수정 사항을 추적할 수 있다. 
> - 소프트웨어의 진행 정도를 확인하기 위한 기준으로 사용될 수 있다. 

#### 3. 형상 관리 기능
> - 형상 식별 : 형상 관리 대상에 이름과 관리 번호를 부여, 수정 및 추적이 용이하도록 하는 작업
> - 버전 제어 : 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리
> - 형상 통제 : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업 
> - 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
> - 형상 기록 : 형상의 식별, 통제, 감사 작업의 결과를 기록,관리하고 보고서를 작성하는 작업 

#### 4. 소프트웨어 버전 등록 관련 주요 용어
> - 저장소 : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장
> - 가져오기 : 아무것도 없는 저장소에 처음으로 파일을 복사
> - 체크아웃 : 프로그램을 수정하기 위해 저장소에서 파일을 받아온다
> - 체크인 : 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신
> - 커밋 : 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌을 알리고 수정한 후 갱신을 완료한다. 
> - 동기화 : 저장소에 있는 버전으로 자신의 작업 공간을 동기화한다. 

#### 5. 소프트웨어 버전 등록 과정(순서)
> (1) 가져오기 : 저장소에 신규로 파일을 추가한다. 
> (2) 인출
> (3) 예치
> (4) 동기화
> (5) 차이 


### 👏 047 소프트웨어 버전 관리 도구
#### 5. 소프트웨어 버전 등록 과정(순서)

1. 공유 폴더 방식 (최근엔 거의 안 씀)
- 공유 폴더 방식은 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
> - 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사한다.
> - 담당자는 공유 폴더의 파일을 자기 pc로 복사한 후 컴파일 하여 이상 유뮤를 확인한다. 
> - 파일의 오류가 확인되면, 개발자에게 수정을 의뢰한다. 
> - 이상이 없다면 다음날 개발자들이 동작 여부를 다시 확인한다. 
> - 잘못 복사하는 것을 대비하기 위해 변경 사항을 데이터베이스에 기록하여 관리한다.  

2. 클라이언트/서버 방식
- 클라이언트/서버 방식은 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식
> - 서버의 자료를 개발자가 자신의 pc(클라이언트)로 복사하여 작업 후 변경된 내용을 서버에 반영한다.  
> - 모든 버전 관리는 서버에서 수행됨
> - 단점 : 서버에 문제가 생기면 복구되기 전까지 작업이 중단됨
> - 대표적으로 SVC(Subversion)

3. 분산 저장소 방식
- 분산 저장소 방식은 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
> - 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영한 다음 이를 원격 저장소에 반영한다. 
> - 장점 : 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 할 수 있다.
> - 대표적으로 Git이 있다. 

4. Subversion(SVN)
> - 클라이언트/서버 구조로, 서버에는 최신 버전의 파일들과 변경 내역이 관리된다. 
> - 서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영(Commit)한다. 
> - 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에서 함.
> - 커밋(Commit)할 때마다 리비전이 1씩 증가한다.
> - 클라이언트는 대부분의 운영체제에서 사용되지만, 서버는 주로 유닉스를 사용한다. 
> - 무료로 사용 가능

5. Git
> - Git은 분산 버전 관리 시스템으로 2개의 저장소, 지역(로컬)저장소와 원격 저장소가 존재
> - 지역 저장소는 개발자들이 실제 개발을 진행하는 장소로 버전관리가 수행됨
> - 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
> - 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하기 처리됨.
> - 원격 저장소나 네트워크에 문제가 있어도 작업이 가능
> - 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능
> - 파일의 변화를 스냅샷으로 저장하는데, 스냅샷의 포틴터를 가지므로 버전의 흐름을 파악 용이

