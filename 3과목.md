# ‍🏄‍♂️ 정보처리기사 자격증 

# 🐳 3과목 : 데이터베이스 구축 

## 📚 1장 : 논리 데이터베이스 설게

### 👏 070 데이터베이스 설계 
- 데이터 베이스 설계 
> 1. 사용자의 요구를 분석한 후 
> 2. 데이터베이스의 구조에 맞게 변형한 후 
> 3. 특정 DBMS로 데이터 베이스를 구현하여 
> 4. 일반 사용자들이 사용하게 하는 것 

#### 1. 데이터베이스 설계 시 고려사항(일 회 무 보 효 데 ) 중요 
- 무결성 : 정해진 제약 조건을 항상 만족해야함
- 일관성 : 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함 
- 회복 : 장애 발생 시 발생 직전 상태로 복구가 가능해야 함
- 보안 : 불법 데이터로 인한 손실로부터 보호가 가능해야 함 
- 효율성 : 응답시간의 단축, 시스템의 생산성. 저장 공간의 최적화 
- 데이터베이스 확장 : 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 추가가 가능해야함

#### 2. 데이터베이스 설계 순서 (요 개논 물구) 중요
1. 요구 조건 분석 : 요구 조건 명세서 작성
2. 개념적 설계 : **트랜잭션 모델링**
3. 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, **트랜잭션 인터페이스** 설계
4. 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환 
5. 구현 : 목표 DBMS의 DDL(SQL...)로 데이터베이스 생성 

#### 3. 요구 조건 분석 
- 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리형태, 흐름, 제약조건 등을 수집
- 수집된 정보를 바탕으로 요구 조건 명세를 작성 

#### 4. 개념적 설계 
- 트렌잭션 모델링을 병행 수행한다. 
- 독립적인 E-R 다이어그램으로 작성 

#### 5. 논리적 설계 
- DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
- 트랜잭션의 인터페이스를 설계
- 관계형 데이터베이스라면 테이블을  설계하는 단계이다.

#### 6. 물리적 설계 
- 물리적 설계 단계에서는 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 엑세스 경로를 결정한다. 
- 구조는 시스템 성능에 중대한 영향을 미친다. 
- 반드시 포함되어야 할 내용 : 분석, 설계, 레코드 집중
- 기본적인 데이터 단위 : 저장 레코드 

#### 7. 데이터베이스 구현 
- 데이터베이스 구현 단계란 논리적 설계단계와 물리적 설계단계에서 도출된 데이터를 파일로 생성하는 과정이다. 
- DBMS의 DDL(SQL)을 이용하여 빈 데이터베이스 파일을 생성한다.
- 생성된 빈 데이터베이스 파일에 데이터를 입력한다. 
- 응용 프로그램을 위한 트랜잭션을 작성
- 데이터베이스 접근을 위한 응용 프로그램을 작성한다. -


### 👏 071 데이터 모델의 개념 (중요)
- 데이터 모델 : 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순, 추상화해 체계적으로 표현한 개념적 모형이다. 

> - 데이터 모델 구성 요소 : 객체, 속성, 관계
> - 데이터 모델 종류 : 개념적, 논리적, 물리적
> - 데이터 모델에 표시할 요소 : 구조(논리적), 연산, 제약 조건  

#### 1. 데이터 모델의 구성 요소 
> - 개체 
> - 속성
> - 관계 

#### 2. 개념적 데이터 모델 
- 인간이 이해할 수 있는 정보 구조로 표한하기 때문에 정보 모델이라고도 한다. 
- 대표적으로는 E-R 모델이 있다.

#### 3. 논리적 데이터 모델 
- 특정 DBMS(오라클, mysql 등)는 특정 데이터 모델 하나만 선정하여 사용 
- 논리적 데이터 모델은 데이터 간의 관게를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다. (p.303 참조) 네트워크 모델의 단점이 보완된 것이 관계형 데이터베이스 모델이다. 

#### 4. 논리적 데이터 모델의 품질 검증 (개 속 관 식 전) 중요 
1. 개체 : 개체의 주 식별자, 개체 간 상호 배타성 
2. 속성 : 속성의 값 존재  여부, 도매인 정의
3. 관계 : 관계의 명칭, 2개 이상의 노드와 관계 존재 여부, 필수적 관계
4. 식별자 : 식별자의 명칭, 정의
5. 전반적인 품질 검증 항목 : 주제 영역 구성의 적절성, 정규화 여부 

#### 5. 데이터 모델이 표시할 요소 
- 구조 : 개체 타입들 간의 관계로 데이터 구조 및 정적 성질을 표현 
- 연산 : 실제 데이터를 처리하는 작업에 대한 명세
- 제약 조건 : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건 (ex. 1~120살)


### 👏 072 데이터 모델의 구성 요소 - 개체(Entity) = TABLE
- 개체는 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실세계의 대상체이다. 
- 개체 = TABLE
> - 독립적으로 존재하거나 그 자체로도 구별이 가능
> - 유일한 식별자에 의해 식별이 가능 (ex. 교수번호)
> - 개체는 업무 프로세스에 의해 이용된다. 
> - 다른 개체와 하나 이상의 관계가 있다.(교수와 학생)

#### 1. 개체 선정 방법 
- 업무 기술서를 이용
- 실제 업무를 담당하고 있는 담당자와 인터뷰
- 실제 업무를 직접 견학
- 실제 업무에 상요되고 있는 장부 이용
- 이미 구축된 시스템이 있는 경우 시스템의 산출물을 검토
- 자료 흐름도의 자료 저장소를 이용 

#### 2. 개체명 지정 방법
- 해당 업무에서 사용하는 용어로 지정
- 약어 사용은 되도록 제한
- 가능하면 단수 명사를 사용
- 모든 개체명은 유일해야 함
- 가능하면 개체가 생성되는 의미에 따라 이름을 부여 

### 👏 073 데이터 모델의 구성 요소 - 속성(Attribute) = COLUMN

- 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위
- 데이터 항목 또는 데이터 필드에 해당
- 속성의 수를 디그리 또는 차수라고 한다. 

#### 1. 속성의 종류 
1. 속성의 **특성**에 따른 분류 
> - 기본 속성 (자동차명, 연비)
>   - 업무 분석을 통해 정의한 속성
>   - 속성 중 가장 많고 일반적
>   - 업무로부터 분석한 속성이라도 업무상 코드로 정의한 속성은 기본 속성에서 제외됨
> - 설계 속성 (A01-세단, A02-SUV)
>   - 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성
>   - 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성 
> - 파생 속성 (총판매수량, 총판매금액)
>   - 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성 

2. 개체 **구성 방식**에 따른 분류 
> - 기본키 속성 : 개체를 식별할 수 있는 속성
> - 외래키 속성 : 다른 개체와의 관계에서 포함된 속성 
> - 일반 속성 : 기본키, 외래키에 포함되지 않은 속성 

#### 2. 속성 후보 선정 원칙
- 원시 속성으로 판단되는 속성 후보는 버리지 않는다. 
- 소그룹별로 속성 후보군을 만들고 가장 근접한 개체에 할당한다. 

#### 3. 속성명 지정 원칙
- 업무에서 사용하는 용어로 지정
- 서술형으로 지정하지 않는다. 
- 약어의 사용은 제한
- 개체명은 속성명으로 사용할 수 없다. 
- 개체에서 유일하게 식별 가능하도록 지정 

### 👏 074 데이터 모델의 구성 요소 - 관계(Relationship)
- 관계 : 개체와 개체 사이의 논리적인 연결을 의미한다. 
- 관계에는 개체간 관계와 속성 간 관계가 있다. 

#### 1. 관계의 형태 
- 일대일
- 일대다
- 다대다

#### 2. 관계의 종류 (중요)
- 종속 관계 : 두 개체 상의 주종 관계를 표현한 것으로 식별 관계와 비식별 관계가 있다. 
- 중복 관계 : 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계 
- 재귀 관계 : 개체가 자기 자신과 관계를 갖는 것
- 배타 관계 
  - 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계로 AND관계와 배타 OR관계로 구분한다.
  - 배타 AND 관계 : 하나의 개체만을 선택할 수 있다.(정규직/비정규직)
  - 배타 OR 관계 : 하나 이상의 개체를 선택할 수 있다. (방문주문/인터넷주문)

#### 3. 식별관계, 비식별관계 (p311 그림 참조)
1. 식별관계 
    - 개체 A, B 사이의 관계에서 A개체의 기본키가 B개체의 외래키이면서 동시에 기본키가 되는 관계를 말한다. 
    - 의존적인 경우에 발생
    - 실선으로 표시 
2. 비식별관계
    - 개체 A, B 사이의 관계에서 A 개체의 기본키가 B 개체의 비기본키 영역에서 외래키가 되는 관계를 말한다. 
    - 일반적으로 비식별 관계로 존재하는 경우가 많다. 
    - ER 도형에서 비식별 관계는 점선으로 표시한다. 

### 👏 075 식별자 
- 식별자는 하나의 객체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자
- 모든 객체는 한 개 이상의 식별자를 반드시 가져야 한다. 
> - 대표성 여부 : 주 식별자 / 보조 식별자
> - 스스로 생성 여부 : 내부 식별자 / 외부 식별자
> - 단일 속성 여부 : 단일 식별자 / 복합 식별자
> - 대체 여부 : 원조 식별자 / 대리 식별자

####  1. 주 식별자/보조 식별자
- 주 식별자 : 개체를 대표하는 유일한 식별자
- 보조 식별자 : 주 식별자를 대신하여 개체를 식별할 수 있는 속성 
- 하나의 개체에 보조 식별자는 하나 이상 존재한다. 
- 개체를 유일하게 식별할 수 있는 속성이 두 개 이상인 경우 업무에 가장 적합한 속성을 주 식별자로 지정하고, 나머지는 보조 식별자로 지정한다. 
- 물리적 테이블에서 주 식별자는 기본키로, 보조 식별자는 유니크 인텍스로 지정되어 사용된다. 

주 식별자의 4가지 특징
> 1. 유일성 : 유일하게 구분되어야 함
> 2. 최소성 : 주 식별자를 구성하는 속성의 수는 최소 수가 되어야 한다. 
> 3. 불변성 : 주 식별자가 한 번 지정되면 변하지 않아야 한다.
> 4. 존재성 : 주 식별자가 지정되면 반드시 데이터 값이 존재해야 한다. 

#### 2. 내부 식별자/외부 식별자
- 내부 식별자는 개체 내에서 스스로 만들어지는 식별자
- 외부 식별자는 외부 개체의 식별자를 가져와 사용하는 식별자
- 외부 식별자는 자신의 개체에서 다른 개체를 찾아가는 연결자 역할을 한다. 

#### 3. 단일 식별자/복합 식별자 
- 단일 식별자 : 한 가지 속성으로만 구성된 식별자
- 복합 식별자 : 두 개 이상의 속성으로 구성된 식별자 

#### 4. 원조 식별자/대리 식별자
- 원조 식별자 : 업무에 의해 만들어지는 가공되지 않은 원래의 식별자 
- 대리 식별자 : 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자 ex) 학번 : 2015(연도)/00(학과코드)/52(순번)

#### 5. 대리 식별자의 조건 
- 최대한 범용적인 값을 사용
- 유일한 값을 만들기 위해 대리 식별자를 사용
- 하나의 대리 식별자 속성으로 대체할 수 없는 경우를 주의 
- 편의성과 단순성, 의미의 체계화를 위한 대리 식별자를 사용할 수 있다. 
- 시스템적인 필요성에 의해 내부적으로만 사용하는 대리 식별자를 사용할 수 있다. 

#### 6. 후보 식별자 
- 후보 식별자는 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합을 의미한다. 
- 후보 식별자 조건 
  - 각 인스턴스를 유일하게 식별할 수 있어야 한다. 
  - 속성들을 직접 식별할 수 있어야 한다.
  - 널 값이 될 수 없다.
  - 개념적으로 유일해야 한다. 
  - 후보 식별자의 데이터는 자주 변경되지 않아야 한다. 

### 👏 076. E-R 모델 (p.317 그림)

- E-R 모델에서는 데이터를 개체, 관계, 속성으로 묘사한다. 
- E-R 다이어그램 표기법에는 피터첸 / 정보 공학 / 바커 표기법 등이 있다.

#### 1. 피터 첸 표기법 
- 사각형 : 개체
- 마름모 : 관계
- 타원 : 속성
- 이중 타원 : 다중값 속성
- 밑줄 타원 : 기본키 속성
- 복수 타원 : 복합 속성(성명은 성과 이름으로 구성)
- 관계 : 1:1, 1:N, N:M 등의 객체 간 관계에 대한 대응수를 선 위에 기술함
- 선, 링크 : 개체 타입과 속성을 연결 

#### 2. 정보 공학 표기법 
- 개체는 사각형 박스로 표시하고 개체명은 박스 바깥쪽 위에 표시
- 속성은 기본키 속성과 일반 속성을 분리하여 표시
- 관계는 관계 표기 기호를 사용하여 표시
- 관계 표기 기호
> - ㅣ: 필수
> - O : 선택적
> - < : 다중

#### 3. 바커 표기법 
- 개체는 모서리가 둥근 박스로 표시
- 개체명은 박스 안 가장 위에 표시
- 속성은 반드시 값이 저장되어야 하는 경우* 표시 
- 값이 저장될 수도 안될 수도 있는 경우 O표시 
- 관계 표기 기호
- ㅡㅡㅡㅡ : 필수
- -------- : 선택적
- < : 다중 

### 👏 077 관계형 데이터 모델

#### 1. 관계형 데이터 모델
- 관계형 데이터 모델은 가장 널리 사용되는 데이터 모델로, 2차원적인 표를 이용해서 데이터 상호 관계를 정의하는 DB 구조를 말한다. 
- 기본키와 이를 참조하는 외래키로 데이터 간의 관계를 표현한다. 

### 👏 078 관계형 데이터베이스의 구조 

- 장점 : 간겨러하고 보기 편리하며 다른 데이터베이스로의 변환이 용이
- 단점 : 성능이 다소 떨어짐

#### 1. 관계형 데이터베이스의 Relation 구조 
1. 튜플 
    - 튜플은 릴레이션을 구성하는 각각의 행을 말한다.
    - 파일 구조에서 레코드와 같은 의미
    - 튜플의 수를 카디널리티라고 한다.

2. 속성
    - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
    - 데이터 항목 또는 데이터 필드에 해당된다.
    - 속성은 개체의 특성을 기술한다.
    - 속성의 수를 디그리 또는 차수라고 한다. 

3. 도메인 
    - 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합이다. 

#### 2. 릴레이션의 특징 
- 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다.
- 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
- 튜플들의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변한다. 
- 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요치 않다.
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다. 
- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키로 설정한다. 
- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다. 

> 릴레이션
> - 속성 = 필드 = 열 = 컬럼(디그리, 차수)
> - 튜플 = 행 = 레코드(카디널리티)

### 👏 079 관계형 데이터베이서의 제약 조건 - 키(key)
- 키는 데이터베이서에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다. 
- 키의 종류에는 후보키, 기본키, 대체키, 슈퍼키, 외래키가 있다. 

#### 1. 후보키 
- 후보키는 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들을 말한다. 
- 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다. 
- 후보키는 유일성과 최소성을 만족시켜야 한다. 

#### 2. 기본키 
- 기본키는  후보키 중에서 특별히 선정된 주키로 중복된 값을 가질 수 없다. 
- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 
- 기본키는 null값을 가질 수 없다. 즉 튜플에서 기본키로 설정된 속성에는 null값이 있어서는 안 된다. 

#### 3. 대체키
- 대체키는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다. 
- 보조키라고도 한다. 

#### 4. 슈퍼키 
- 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다. 
  
#### 5. 외래키
- 외래키는 다른 릴레이션의 기본키를 참조하는 속성을 의미한다. 
- 외래키는 릴레이션 간에 참조 관계를 표현하는데 중요한 도구이다. 
- 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값을 입력할  수 없다. 


### 👏 080 관계형 데이터베이서의 제약 조건 - 무결성

- 무결성 : 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미한다.
- 무결성의 종류 **(무결성 개도참사)**
> - 개체 무결성
> - 도메인 무결성
> - 참조 무결성
> - 사용자 정의 무결성

#### 1. 개체 무결성 
- 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL값이나 중복값을 가질 수 없다는 규정 

#### 2. 도메인 무결성 
- 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정 

#### 3. 참조 무결성
- 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정 

#### 4. 사용자 정의 무결성 
- 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다는 규정 

#### 5. 데이터 무결성 강화 
- 데이터 무결성은 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용해 강화할 수  있다.

1. 애플리케이션 : 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터에 조작하는 프로그램 내에 추가한다. 
    - 장점 : 복잡한 무결성 조건의 구현이 가능하다. 
    - 단점 : 소스 코드에 분산되어 있어 관리가 힘들고, 개별적인 시행으로 인해 적정성 검토가 어렵다. 

2. 데이터베이스 트리거 : 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가한다. 
    - 장점 : 통합 관리가 가능하고 복잡한 요구 조건의 구현이 가능
    - 단점 : 운영 중 변경이 어렵고, 사용상 중의가 필요하다. 

3. 제약 조건 : 데이터베이서에 제약 조건을 설정하여 무결성을 유지한다. 
    - 장점 : 통합관리기능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생
    - 단점 : 복잡한 제약 조건의 구현과 예외적인 처리가 불가능 


### 👏 081 관계대수 및 관계해석

#### 1. 관계대수 
- 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어
- 피연산자가 릴레이션이고, 결과도 릴레이션이다. 

> - 순수 관계 연산자 : Select, Project, Join, Division
> - 일반 집합 연산자 : UNION, INTERSECTION, DIFFERENCE, CARTESIAN

#### 2. Select 
- 릴레이션의 행에 해당하는 튜플을 구하는 것 (수평)
- 연산자의 기호는 시그마를 사용 
- 표기 형식 : σ

#### 3. Project
- Project는 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출 (수직)
- 표기 형식 : π

#### 4. Join 

- 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산 
- 표기형식 : ⋈
- 자연조인 : 조인조건이 =일 때 동일한 속성이 두 번 나타나게 되는데, 이중 중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 자연 조인이라고 한다.

#### 5. Division
- R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
- R[속성r ÷ 속성s]S

#### 6. 일반 집합 연산자 
- 합집합(UNION) : 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않다. 
- 교집합(INTERSECTION) : 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다. 
- 차집합(DIFFRENCE) : 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않다. 
- 교차곱(CARTESIAN) : 교차곱은 두 릴레이션의 카디널리티를 곱한 것과 같다. 

#### 7. 관계해석
- 관계해석은 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용 
- 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 가짐
- 질의어로 표현(SQL)


### 👏 082 정규화
- 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
- 정규형에는 제1정규형(2,3,4,5), BCNF형 이 있다. 
- 정규화는 데이터베이스의 논리적 설계 단계에서 수행한다. 
- 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성을 보장

#### 1. 정규화의 목적 
- 데이터 중복을 배제하여 이상의 발생 방지 및 자료 저장 공간의 최소화가 가능

#### 2. 이상의 개념 및 종류 (Anomaly)
1. 삽입 이상 : 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들도 함께 삽입되는 현상
2. 삭제 이상 : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상
3. 갱신 이상 : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상


#### 3. 정규화의 원칙
- 정보의 무손실 표현, 즉 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는 안 된다.
- 데이터의 중복성이 감소되어야 한다. 

#### 4. 정규화 과정 (두부이걸다줘?)
- 1NF : 릴레이션의 모든 속성 값이 원자 값으로만 되어있는 정규형(**도**메인이 원자값)
- 2NF : 완전 함수적 종속을 만족하는 정규형(**부**분적 함수 종속 제거)
- 3NF : 이행적 종속을 만족하지 않는 정규형(**이**행적 함수 종속 제거)
- BCNF : 결정자가 모두 후보키인 정규형(**결**정자이면서 후보키가 아닌 것 제거)
- 4NF : **다**치종속 제거
- 5NF : **조**인 종속성 이용


### 👏 083 반정규화 (중요)
- 반정규화 : 의도적으로 정규화 원칙을 위배하는 행위
- 과도한 반정규화는 오히려 성능을 저하시킬 수 있다.
- 반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가

#### 1. 테이블 통합
- 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우, 두 개의 테이블을 이용해 항상 조회를 수행하는 경우 테이블 통합을 고려한다. 
- 테이블 통합 시 고려사항
> - 테이블 검색은 간편하지만 레코드 증가로 인해 처리량이 증가
> - 테이블 통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있다. 
> - Not Null, Default, Check 등의 제약 조건을 설계하기 어렵다. 

#### 2. 테이블 분할
1. 수평 분할 : 레코드를 기준으로 테이블을 분할
2. 수직 분할 : 테이블에 속성이 너무 많을 경우 속성을 기준으로 분할
    - 갱신 위주의 속성 분할
    - 자주 조회되는 속성 분할
    - 크기가 큰 속성 분할 
    - 보안을 적용해야 하는 속성 분할 
- 테이블 분할 시 고려사항
> - 기본키의 유일성 관리가 어려워진다.
> - 데이터 양이 적거나 사용 빈도가 낮은 경우 테이블 분할이 필요한지 고려
> - 분할된 테이블로 인해 수행 속도가 느려질 수 있다. 
> - 데이터 검색에 중점을 두어 테이블 분할 여부를 결정해야 한다. 

#### 3. 중복 테이블 추가 
- 중복 테이블을 추가하는 경우 
  - 정규화로 인해 수행 속도가 느려지는 경우
  - 많은 범위의 데이터를 자주 처리해야 하는 경우
  - 특정 범위의 데이터만 자주 처리해야 하는 경우
  - 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우

- 중복 테이블을 추가하는 방법
  - 집계 테이블의 추가
  - 진행 테이블의 추가
  - 특정 부분만을 포함하는 테이블의 추가 : 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성한다. 

#### 4. 중복 속성 추가 
- 중복 속성을 추가하는 경우
  - 조인이 자주 발생하는 속성인 경우
  - 접근 경로가 복잡한 속성인 경우
  - 엑세스 조건으로 자주 사용되는 속성인 경우(where절 같은 곳에 자주 언급되는 경우)
  - 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우 

- 중복 속성 추가 시 고려사항
  - 테이블 중복과 속성 중복을 고려
  - 데이터 일관성 및 무결성에 유의
  - 그룹함수를 이용하여 처리할 수 있어야 한다.
  - 저장 공간의 지나친 낭비를 고려

### 👏 084 시스템 카탈로그
- 시스템 카탈로그 : 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스다. 
- 데이터 사전이라고도 한다. 

#### 1. 시스템 카탈로그 저장 정보 
- 시스템 카탈로그에 저장된 정보를 메타 데이터라고 한다. 
- 메타 데이터의 유형
> - 데이터베이스 객체 정보 : 테이블, 인덱스, 뷰
> - 사용자 정보 : 아이디, 패스워드, 접근 권한
> - 테이블의 무결성 제약 조건 정보 : 기본키, 외래키. NULL값 허용 여부
> - 함수, 프로시저, 트리거

#### 2. 카탈로그의 특징 
- 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다. 
- INSERT, DELETE, UPDATE문으로 카탈로그를 갱시하는 것은 허용되지 않는다.
- 데이터베이스 시스템에 따라 상이한 구조를 갖다.(오라클, 마이에스큐엘 등 서로 다 다름)
- 카탈로그는 DBMS가 스스로 생성하고 유지한다. 
- 카탈로그의 갱신 : 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신한다. 
- 분산 시스템에서의 카탈로그 : 보통의 릴레이션 정보를 포함할뿐 아니라 위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 한다.

#### 3. 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템
- 데이터 정의어 번역기(DDL 컴파일러) : DDL을 메타 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장 
- 데이터 조작어 변역기(DML 컴파일러) : DML문을 프로시저 호출로 변환하여 질의 처리가와 상호 통신한다. 


## 📚 2장 : 물리 데이터베이스 설계
### 👏 085 사전 조사 분석

#### 1. 물리 데이터베이스  설계
- 물리 데이터베이스 설계는 논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적  저장 장치에 저장할 수 있는 물리적 데이터로 변환하는 과정이다. 
- 물리적 데이터베이스 구조는 데이터베이스 시스템의 성능에 중대한 영향을 미친다.
- 물리적 설계 시 고려사항 
  - 인덱스 구조
  - 레코드 크기
  -  파일에 존재하는 레코드 개수
  -  파일에 대한 트랜잭션의 갱신과 참조 성향
  -  성능 향상을 위한 개념 스키마의 변경 여부
  -  빈번한 질의와 트랜잭션의 수행속도를 높이기 위한 고려
  -  시스템 운용 시 파일 크기의 변화 가능성 

#### 2. 데이터 명명 규칙 파악
1. 명명 규칙은 물리 데이터 모델의 설계 전에 파악해야 한다. 
2. 데이터 명명 규칙은 데이터 표준화 및 논리 데이터베이스 설계의 결과물 등을 통해 파악한다. 
3. 명명 규칙은 서로 일관성을 유지해야 한다. 
4. 데이터 명명 규칙을 통해 중복 구축 등을 방지할 수 있다.
5. 도메인 : 객체에 포함된 속성들의 데이터 타입, 크기 등을 표준화 규칙에 따라 일관성 있게 정의한 것을 의미한다. 
6. 데이터사전
   -  전체 프로젝트 과정에서 일관성 있는 데이터 이름과 인터페이스르 제공하기 위해 속성의 논리명, 용어 정의를 기술해 놓은 것이다.

#### 3. 시스템 자원 파악 
- 하드웨어 자원
- 운영체제 및 DBMS 버전
  - 운영체제와 DBMS 버전은 데이터베이스 운영에 영향을 미칠 수 있으므로 관련 요소 등을 파악하고 적절하게 관리해야 한다. 
- DBMS 파라미터 정보
  - 시스템별 DBMS 파라미터 종료 및 관리 대상 등을 파악한다.
  - 옵티마이저(SQL문을 수행할 가장 효율적이고 빠른 방법을 선택해주는 DBMS핵심 엔진)의 사용 방법 등을 파악한다. 

#### 4. 데이터베이스 관리 요소 파악(중요)
- 데이터베이스 구조 : 데이터베이스의 구조에 따라 문제 발생 시 대응 방법이 다르므로 서버와 데이터베이스의 구조 등을 파악한다.
- 이중화 구성 : 문제 발생에 대비하여 동일한 데이터베이스를 복재하여 관리하는 이중화 구성을 파악한다. 
- 분산 데이터베이스 : 분산 데이터베이스는 물리적 재해 및 파손 등 데이터 유실을 최소화할 수 있고 장애로 인한 데이터 유실 복구에 효과적이므로 데이터베이스의 분산 구조를 파악한다.
- 접근제어/접근통제 : 접근 가능한 사용자의 권한 남용으로 인한 정보 유출 및 변조가 가장 빈번하게 발생하므로 데이터베이스의 접근 제어 방법 등을 파악한다. 
- DB암호화 : DB암호화는 데이터 암호화, 암호 키에 대한 인증 등을 통해 데이터 유출 시 데이터의 복호화를 어렵게 하므로 DB암호화의 특성을 파악한다.

### 👏 086 데이터베이스 저장 공간 설계

#### 1. 테이블
- 테이블 : 데이터베이서의 가장 기본적인 객체로 로우(행)와 컬럼(열)으로 구성되어 있다.

#### 2. 일반 테이블 
- 일반 테이블 : 현재 사용되는 대부분의 DBMS에서 표준 테이블로 사용되는 테이블 형태
- 테이블에 저장되는 데이터의 로우 위치는 속성 값에 상관없이 데이터가 저장되는 순서에 따라 결정된다.

#### 3. 클러스터드 인덱스 테이블 (중요)
- 클러스터드 인덱스 테이블은 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블이다. 
#### 4. 파티셔닝 테이블 
- 파티셔닝 테이블 : 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블이다. 
- 파티셔닝 방식에 따라 범위 분할, 해시 분할, 조합 분할 등으로 나뉜다.
  - 범위 분할 : 값을 기준으로 분할
  - 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
  - 조합 분할 : 범위 분할로 해시 함수를 적용하여 다시 분할하는 방식 

#### 5. 외부 테이블 
- 외부 테이블은 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로, 데이터베이스 내에 객체로 존재한다. 
- 외부 테이블은 데이터웨어하우스에서 ETL 등의 작업에 유용하게 사용된다. 

#### 6. 임시 테이블
- 임시 테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제된다.
- 절차적인 처리를 위해 임시로 사용하는 테이블 

#### 7. 컬럼 
- 데이터 타입과 길이 지정 시 고려사항 
  - 가변 길이 데이터 타입 : 예상되는 최대 길이로 정의
  - 고정 길이 데이터 타입 : 최소 길이로 지정
  - 소수점 이하 자릿수 : 소수점 이하 자리수는 반올림되어 저장

- 데이터 타입에 따른 컬럼의 물리적인 순서
  - 고정 길이 컬럼이고 NOT Null인 컬럼 : 앞쪽
  - 가변 길이 컬럼 : 뒤쪽
  - Null 값이 많을 것으로 예상되는 컬럼 : 뒤쪽 

#### 8. 테이블스페이스
- 테이블스페이스 : 테이블이 저장되는 논리적인 영역으로, 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있다. 
- 데이터베이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장된다. 
- 테이블 스페이스 설계 시 고려사항 
  - 테이블스페이스는 업무별로 구분하여 지정한다. 
  - 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장한다. 
  - 테이블과 인덱스는 분리하여 저장한다. 
  - LOB(큰, Large Object) 타입의 데이터는 독립적인 공간으로 지정한다. 

### 👏 087 트랜잭션 분석 / CRUD 분석

#### 1. 트랜잭션 정의

- 트랜잭션 : 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다. 
- 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용된다. 
- 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변화 괒정의 작업 단위로 사용된다. 

#### 2. 트랜잭션의 특성 (ACID) 돈 송금으로 개념 이해 
- Atomicity(원자성)
  - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다. 
- Consistency(일관성)
  - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
- Isolation(독립성)
  - 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다. 
- Durability(영속성)
  - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

#### 3. CRUD 분석
- CRUD는 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 앞 글자만 모아서 만든 용어다.
- CRUD 분석으로 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악한다.
- CRUD 분석을 통해 많은 트랜잭션이 몰리는 테이블을 파악한다. 
- 트랜잭션의 부하가 집중되는 데이터베이스 채널을 파악하고 분산시킴으로써 연결 지연이나 타임아웃 오류를 방지할 수 있다. 

#### 4. 트랜잭션 분석
- 트랜잭션 분석의 목적은 DB 구조를 최적화 하는 것이다. 
- 트랜잭션 분석은 업무 개발 담당자가 수행한다. 
- 프로세스가 과도하게 접근하는 테이블을 확인하여 여러 디스크에 배치함으로써 디스크 입출력 분산을 통한 성능 향상을 가져올 수 있다. 

### 👏 088 인덱스 설계
- 인덱스 : 데이터 레코드를 빠르게 접근하기 위해 <키, 값, 포인터>로 구성되는 데이터 구조다. 
- 인덱스에서 키 값은 '학번'이고 포인터는 해당 '학번'이 저장된 레코드의 물리적인 주소이다. 키 값인 '학번'이 정렬되어 있기 때문에 인덱스를 통해 레코드를 빠르게 접근할 수 있다. 

#### 1. 클러스터드 인덱스
- 인덱스 키의 순서에 따라 정렬되어 저장되는 방식
- 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다.
- 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 정렬해야 한다. (단점)
- 한 개의 릴레이션에 하나의 인덱스만 생성할 수 있다. 


#### 2. 넌클러스터드 인덱스
- 인덱스 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
- 데이터를 검색하기 위해서는 먼저 인덱스를 검색하여 실제 데이터의 위치를 확인해야 하므로 클러스터드 인덱스에 비해 검색 속도가 떨어진다. (단점)
- 한 개의 릴레이션에 여러 개의 인덱스를 만들 수 있습니다.

#### 3. 트리 기반 인덱스
- 트리 기반 인덱스 : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것

1. B 트리 인덱스 
   - 루트 노드에서 하위 노드로 키 값의 크기를 비고해 나가면서 단말 노드를 찾고자 하는 데이터를 검색한다. 

2. B+ 트리 인덱스
   - 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈수 있는 경로로만 제공됨
   - 단말 노드만을 이용한 순차 처리가 가능하다. 

#### 4. 비트맵 인덱스
- 비트맵 인덱스 : 인덱스 컬럼의 데이터를 bit값인 0 또는 1로 변환하여 인덱스 키로 사용
- 비트맵 인덱스의 목적은 키 값을 포함하는 로우의 주소를 제공 
- 비트맵 인덱스는 분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있다. 
- 데이터가 bit로 구성되어 있기 때문에 효율적인 논리 연산이 가능하고 저장 공간이 작다. 
- 다중 조건을 만족하는 튜플의 개수 계산에 적합하다.
- 동일한 값이 반복되는 경우가 많아 압축 효율이 좋다. 

#### 5. 함수 기반 인덱스
- 함수 기반 인덱스 : 컬럼 값 대신 컬럼에 특정 함수나 수식을 적용해 산출된 값을 사용
- 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하가 발생할 수 있다.
- 사용된 함수가 사용자 정의 함수일 경우 시스템 함수보다 부하가 더 크다
- 함수 기반 인덱스는 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용된다. 

#### 6. 비트맵 조인 인덱스
- 비트맵 조인 인덱스 : 다수의 조인된 객채로 구성된 인덱스

#### 7. 도메인 인덱스 
- 도메인 인덱스 : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장향 인덱스라고도 한다. 
- 개발자가 필요에 의해 만들었지만 프로그램에서 제공하는 인덱스처럼 사용할 수도 있다. 

#### 8. 인덱스 설계
- 인덱스 설계 순서
    1. 인덱스의 대상 테이블이나 컬럼 등을 선정한다. 
    2. 인덱스의 효율성을 검토하여 인덱스 최적화를 수행한다. 
    3. 인덱스 정의서를 작성한다. 

#### 9. 인덱스 대상 테이블 선정 기준
- MULTI BLOCK READ 수에 따라 판단(만약 16이면,테이블의 크기가 16블록 이상일 경우 인덱스 필요)
- 랜덤 엑세스가 빈번한 테이블
- 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
- 다른 테이블과 순차적 조인이 발생되는 테이블

#### 10. 인덱스 대상 컬럼 선정 기준 (중요)
- 인덱스 컬럼의 분포도가 10~15% 이내인 컬럼
- 분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼
- 조회 및 출력 조건으로 사용되는 컬럼
- 인덱스가 자동 생성되는 기본키와 Unique키 제약 조건을 사용한 컬럼 
- 가능한 한 수정이 빈번하지 않은 컬럼
- ORDER BY, GROUP BY, UNION이 빈번한 컬럼
- 분포도가 좁은 컬럼은 단독 인덱스로 생성
- 인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성 

#### 11. 인덱스 설계 시 고려사항
- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있다.
- 인덱스를 지나치게 많이 만들면 오버헤드가 발생한다.
- 넓은 범위를 인덱스로 처리하면 많은 오버헤드가 발생한다.
- 인덱스를 만들면 추가적인 저장공간이 필요하다.
- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계한다. 


### 👏 088 인덱스 설계

#### 1. 뷰의 개요
- 뷰는 가상테이블이다. 
- 뷰는 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는  것처럼 간주된다.
- 뷰는 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용된다. 


#### 2. 뷰의 특징 
- 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다.
- 데이터의 논리적 독립성을 제공할 수 있다.(원하는 데이터만 따로 떼서 테이블을 만들 수 있어서)
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
  - SQL, 쿼리 간소화
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다. 
  - 어떤 테이블에서 주민번호를 제외한 데이터를 모은 뷰를 생성해서 배포해 개인정보 보호가능
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능 
- 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다. 
  - 어떤 테이블에서 만든 뷰를 통해 새로운 뷰를 만들 수 있다. 
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를  기초로 정의된 다른 뷰도 자동으로 삭제된다. 

#### 3. 뷰의 장단점 
- 장점
  - 논리적 데이터 독립성을 제공
  - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해준다.(사용자들에게 각각 필요한 데이터만 제공가능)
  - 사용자의 데이터 관리를 간단하게 해준다.(SQL, 질의 간소화)
  - 접근 제어를 통한 자동 보안이 제공된다. 

- 단점
  - 독립적인 인덱스를 가질 수 없다. 
  - 뷰의 정의를 변경할 수 없다. 
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다.

#### 4. 뷰 설계 순서
1. 대상 테이블을 선정한다.  
     - 외부 시스템과 인터페이스에 관여하는 테이블 
     - 여러 테이블이 동시에 자주 조인되어 접근되는 테이블
     - SQL문 작성 시 거의 모든 문장에서  인라인 뷰 방식으로 접근되는 테이블  
2. 대상 컬럼을 선정한다.
3. 정의서를 작성한다. 


#### 5. 뷰 설계 시 고려 사항

- 테이블 구조가 단순화 될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성한다.(자주 조인되는 것들을 모아 뷰로 만들면 편함)
- 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시해야 한다. 
  - ex) 회원 테이블은 회원번호, 이름, 주소, 전화번호, 총구매횟수, 총구매금액 필드로 구성되어 있는데, 제품 발송 업무를 처리할 때는 이름, 주소, 전화번호 필드만 필요하므로 이 3개의 필드로 구성된 뷰를 설계한다.
- 데이터의 보안 유지를 고려하여 설계한다.
  - 회원 테이블의 총구매횟수, 총구매금액은 회사 차원에서 중요한 자료일 수 있으므로 발송 담당자가 볼 수 없도록 뷰를 설계한다.


### 👏 090 클러스터 설계

#### 1. 클러스터 개요
- 클러스터 : 데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법이다.
- 클러스터링키로 저장된 컬럼 값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장된다. 
> - <부서> 테이블과 <사원> 테이블이 부서번호 필드를 기준으로 클러스터링 되었다. 이런 경우 부서번호를 클러스터링키라고 한다. 

#### 2. 클러스터의 특징

- 클러스트링 된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킨다.
- **클러스터는 데이터의 분포도가 넓을수록 유리하다. (인덱스는 좁을수록 유리)**
- 데이터 분포도가 넓은 테이블을 클러스트링 하면 저장 공간을 절약할 수 있다. 
- 클러스터링된 테이블은 클러스터링키 열을 공유하므로 저장공간이 줄어든다. 
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋다. 
- 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용한다.
- 파티셔닝된 테이블에는 클러스터링을 할 수 없다. 
- 클러스터링을 하면 비슷한 데이터가 동일한 데이터 블록에 저장되기 때문에 디스크 I/O가 줄어든다.
- 클러스터링 된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상된다.


#### 3. 클러스터 대상 테이블(중요)
- 분포도가 넓은 테이블
- 대량의 범위를 자주 조회하는 테이블
- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
- 자주 조인되어 사용되는 테이블
- ORDER BY, GROUP BY, UNION이 빈번한 테이블

### 👏 091 파티션 설계

#### 1. 파티션의 개요
- 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다. 
- 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워진다. 

#### 2. 파티션의 장단점(중요)
- 장점
  - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상된다.
  - 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상된다.
  - 파티션별로 백업 및 복구를 수행하므로 속도가 빠르다.
  - 시스템 장애 시 데이터 손상 정도를 최소화할 수 있다.
  - 데이터 가용성이 향상된다.
  - 파티션 단위로 입,출력을 분산시킬 수 있다.

- 단점 
  - 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구된다.
  - 테이블간 조인에 대한 비용이 증가한다.
  - 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하된다. 

#### 3. 파티션의 종류 
- 범위분할 : 지정한 열의 값을 기준으로 분할(일별, 월별, 분기별)
- 해시분할 : 해시함수를 적용한 결과 값에 따라 데이터를 분할한다.
- 조합분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식이다.

#### 4. 파티션키 선정 시 고려사항 (중요)
- 파티션키는 테이블 **접근 유형에 따라** 파티셔닝이 이뤄지도록 선정한다.
- 이력성 데이터는 파티션 생성주기와 소멸주기를 일치시켜야 한다.
- 매일 생성되는 날짜컬럼, 백업의 기준이 되는 날짜 컬럼, 파티션 간 **이동이 없는 컬럼**, **I/O 병목**을 줄일 수  있는 데이터 **분포가 양호한 컬럼** 등을 파티션키로 선정한다.

#### 5. 인덱스 파티션 
- 인덱스 파티션 : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것이다. 
- 파티션된 테이블의 종속 여부에 따라 Local과 Global로 나뉜다.
  - Local Partitioned Index : 테이블 파티션과 인덱스 파티션이 1:1 대응됨
  - Global Partitioned Index : 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티션

- 컬럼의 위치에 따라 Prefixed와 Non Prefixed로 나뉜다.
  - Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 같다.
  - Non Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다르다. 


### 👏 092 데이터베이스 용량 설계

- 데이터베이스 용량 설계 : 데이터가 저장될 공간을 정의하는 것이다. 
- 데이터베이스 용량을 설계할 때는 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야 한다. 

#### 1. 데이터베이스 용량 설계의 목적(중요)
- 데이터베이스의 용량을 정확히 산정하여 디스크의 저장공간을 효과적으로 사용하고 확장성 및 가용성을 높인다.
- 디스크의 특성을 고려하여 설계함으로써 디스크의 입,출력 부하를 분산시키고 채널의 병목현성을 최소화한다. 
- 디스크에 대한 입출력 경합이 최소화되도록 설게함으로써 데이터 접근성을 향상된다.
- 데이터 접근성 향상시키는 설계 방법
  - 테이블의 테이블스페이스와 인덱스의 테이블스페이스를 분리하여 구성
  - 테이블스페이스와 임시 테이블스페이스를 분리하여 구성한다. 
  - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류한다.
  - 익스텐트(용량이 다 찼을 때 추가적으로 할당되는 공간) 발생을 최소화하여 성능을 향상 시킨다.

#### 2. 데이터베이스 용량 분석 절차
1. 기초 자료 수집
2. 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 산정
3. 테이블과 인덱스의 테이블스페이스 용량을 산정
     - 테이블 스페이스 용량은 테이블 용량을 모두 더한 값에 약 40% 정도 추가하여 산정  
4. 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리르 위한 시스템 용량을 합해 디스크 용량을 산정한다.

### 👏 093 분산 데이터베이스 설계 

#### 1. 분산 데이터베이스 정의
- 분산 데이터베이스 : 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스를 말한다. 

#### 2. 분산 데이터베이스의 구성요소 (중요.p.390그림 참조)
- 분산 처리기 : 자체적으로 처리 능력을 가진다. 
- 분산 데이터베이스 : 해당 지역의 특성에 맞게 데이터베이스가 구성된다.
- 통신 네트워크 : 분산 처리기들을 통신망으로 연결하여 논리적으로 하나의 시스템처럼 작동할 수 있도록 하는 통신 네트워크를 말한다. 

#### 3. 분산 데이터베이스 설계 시 고려 사항
- 작업부하의 노드별 분산 정책
- 지역의 자치성 보장 정책
- 데이터의 일관성 정책
- 사이트나 회산의 고장으로부터의 회복 기능 
- 통신 네트워크를 통한 원격 접근 기능

#### 4. 분산 데이터베이스의 목표
- 위치 투명성 : 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 엑세스할 수 있다.
- 중복 투명성 : 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용한다. 
- 병행 투명성 : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다. 
- 장애 투명성 : 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다. 

#### 5. 분산 데이터베이스의 장단점 (중요)
- 장점 
  - 지역 자치성이 높다.
  - 공유성이 향상된다.
  - 분산제어가 가능하다.
  - 시스템 성능이 향상된다.
  - 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않는다.
  - 효용성과 융통성이 높다.
  - 신뢰성 및 가용성이 높다.
  - 점진적 시스템 용량 확장이 용이하다. 

- 단점
  - DBMS가 수행할 기능이 복잡하다.
  - 데이터베이스 설계가 어렵다.
  - 소프트웨어 개발 비용이 증가한다.
  - 처리 비용이 증가한다.
  - 잠재적 오류가 증가한다. 


#### 6. 분산 데이터베이스 설계
- 분산 데이터베이스 설계 : 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 한다. 
- 잘못 설계된 분산 데이터베이스는 복잡성 증가, 응답 속도 저하, 비용 증가 등의 문제가 발생한다. 
- 분산 데이터베이스의 설계는 전역 관계망을 논리적 측명에서 소규모 단위로 분할한 후, 복수의 노드에 할당하는 과정으로 진행된다.
- 분산 설계 방법에는 테이블 위치 분산, 분할, 할당이 있다.

#### 7. 테이블 위치 분산 
- 테이블 위치 분산 : 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법을 의미한다. 
> 본사 : 사원 부서 거래업체
> 지사 : 상품 판매현황
> - 이렇게 서버마다 분산시킴 

#### 8. 분할(중요)
- 분할 : 테이블의 데이터의 분할하여 분산시키는 것
- 분할 규칙
  - 완전성 : 전체 데이터를 대상으로 분할해야 한다.
  - 재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 한다. 
  - 상호 중첩 배체 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 한다. 

- 분할 방법
  - 수직 분할
  - 수평 분할

#### 9. 할당 
- 할당 : 동일한 분할을 여러 개의 서버에 생성하는 분산 방법으로, 중복이 없는 할당과 중복이 있는 할당을 나뉜다. 
- 비중복 할당 방식 : 분산 데이터베이스의 단일 노드에서만 분할이 존재하도록 하는 방식이다.
- 중복 할당 방식 : 동일한 테이블을 다른 서버에 복제하는 방식(서울, 부산에서 같은 데이터를 복제하여  서로 다른 서버에서 사용)


### 👏 094 데이터베이스 이중화 / 서버 클러스터링

#### 1. 데이터베이스 이중화 
- 데이터베이스 이중화 : 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것이다.

#### 2. 데이터베이스 이중화의 분류
- Eager 기법 : 트랜잭션 수행 중 데이터 변경이 발생하면 이준화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법 
- Lazy 기법 : 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법 

#### 3. 데이터베이스 이중화 구성 방법 
- 활동 대기 방법 : 활성 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행한다. 
- 활동 활동 방법 : 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공한다.

#### 4. 클러스터링
- 클러스티링 : 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
- 클러스팅은 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공한다.
  - 고가용성 클러스터링 : 하나의 서버에 장애가 발생하면 다른 서버가 받아 처리하여 서비스 중단을 방지하는 방식
  - 병렬 처리 클러스터링 : 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식 

### 👏 095 데이터베이스 보안 / 암호화
- 데이터베이스 보안 : 데이터베이서의 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술

#### 1. 개인키 암호 방식 = 비밀키 암호 방식
- 동일한 키로 데이터를 암호화하고 복호화한다. 
- 장점 : 암호화/복호화 속도 빠르고 파일 크기가 작음
- 단점 : 사용자 증가에 따라 관리할 키의 수가 상대적으로 많아짐

#### 2. 공개키 암호 방식 
- 서로 다른 키로 데이터를 암호화하고 복호화한다. 
- 장점 : 키의 분배가 용이, 관리할 키가 적음
- 단점 : 암호화/복호화 속도가 느리다. 알고리즘 복잡, 크기가 큼
- 대표적으로는 RSA가 있다. 

### 👏 096 데이터베이스 보안 – 접근통제

#### 1. 접근통제
- 비인가된 사용자의 접근 감시
- 접근 요구자의 사용자 식별
- 접근 요구의 정당성 확인 및 기록
- 보안 정책에 근거한 접근의 승인 및 거부

- 접근통제 기술 종류
>- 임의 접근통제 : 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식이다.  
  SQL 명령어에는 GRANT(권한부여) 와 REVOKE(권한취소)가 있다.
>- 강제 접근통제 : 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
주체는 자신보다 보다 
보안 등급이 높은 객체에 대해 읽기, 수정, 등록이 모두 불가능
보안 등급이 같은 객체에 대해서는 읽기, 수정, 등록이 가능
**보안 등급이 낮은 객체는 읽기가 가능**(헷갈림)
- 접근통제 3요소 : (정)책 (보)안모델 메(커)니즘 **정보커**
#### 2. 접근통제 정책
- 신분 기반 정책 : **신분에 근거**하여 객체의 접근을 제한하는 방법
  - IBP(individual) : 단일 주체에게 하나의 객체에 대한 허가를 부여
  - GBP(Group) : 복수 주체에 하나의 객체에 대한 허가를 부여
- 규칙 기반 정책 : 주체가 갖는 **권한에 근거**하여 객체의 접근을 제한하는 방법
  - MLP : 사용자 및 객체별로 지정된 기밀 분류에 따른 정책
  - CBP : 집단별로 지정된 기밀 허가에 따른 정책
- 역할 기반 정책 : GBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 **역할에 근거**하여 객체의 접근을 제한

#### 3. 접근통제 매커니즘
- 접근통제 목록 : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록
- 능력 리스트 : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록
- 보안 등급 : 부여된 보안 속성의 집합으로, 이 등급을 기반으로 접근 승인 여부가 결정
- 패스워드 : 주체가 자신임을 증명할 때 사용하는 인증 방법
- 암호화 : 데이터를 보낼  때 지정된 수신자 이외에는 내용을 알 수 없도록 평문을 암호문으로 변환하 것

#### 4. 접근통제 보안 모델
- 기밀성 모델 : 기밀성 모델은 군사적인 목적으로 개발된 최초의 수학적 모델로, 기밀성 보장이 최우선인 모델이다.
- 제약조건(총모양임)
```js
level      단순보안규칙       스타보안규칙      강한스타보안규칙
            읽기 권한           쓰기권한           읽기/쓰기권한
높은         통제                 가능(-)             통제
같은         가능(-)              가능(-)             가능(-)
낮은         가능(-)              통제                통제
```



- 무결성 모델 : 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
```js
level     단순무결성규칙          스타무결성규칙      
            읽기 권한               쓰기권한          
높은         가능(-)                  통제          
같은         가능(-)                 가능(-)            
낮은          통제                   가능(-)               
``` 


- 접근통제 모델 : 접근통제 모델은 접근통제 메커니즘을 보안 모델로 발전시킨 것
  - ALL, R, R/W로 이루어져있음

#### 5. 접근통제 조건
- 값 종속 통제 : 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용
  - 납입한 금액에 따라 보안등급이 설정되고, 보안 등급에 따라 접근 여부가 결정되는 경우

- 다중 사용자 통제 : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에 사용
  - 여러 명으로 구성된 한 팀에서 다수결에 따라 접근 여부가 결정되는 경우

- 컨텍스트 기반 통제 : 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때 사용
  - 근무시간, 월요일~금요일 9:00~18:00 사이에만 접근가능 

#### 6. 감사 추적
- 감사 추적은 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능
- 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용됨
- 감사 추적 시 실행한 프로그램, 사용자, 날짜 및 시간, 접근한 데이터의 이전 값 및 이후 값 등이 저장됨 

### 👏 097 데이터베이스 백업
- 데이터베이스 백업 : 전산 장비의 장애에 대비해 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업
- DBMS는 데이터베이스 파괴 및 실행 중단이 발생하면 이를 복구할 수 있는 기능을 제공한다. 

#### 1. 데이터베이스 장애 유형 
- 사용자 실수 
- 미디어 장애 : 하드웨어 장애나 데이터가 파손된 경우
- 구문 장애 : 프로그램 오류나 사용 공간의 부족으로 인해 발생하는 장애
- 사용자 프로세스 장애 : 프로그램이 비정상적으로 종료되거나 네트워크 이상으로 세션이 종료되어 발생하는 오류
- 인스턴스 장애 : 메모리나 데이터베이스 서버의 프로세스가 중단된 경우

#### 2. 로그 파일 
- 로그파일 : 상태 변화를 시간의 흐름에 따라 모두 기록한 파일 
- 로그파일 내용 : 트랜잭션이 작업한 모든 내용, 레코드, 식별자, 이전값, 이후값 등 

#### 3. 데이터베이스 복구 알고리즘
- 동기적 갱신 : 트랜잭션이 완료되기 전에 동시적으로 저장매체에 기록하는 것
- 비동기적 갱신 : 트랜잭션이 완려된 내용을 일정 주기나 작업량에 따라 시간 차이를 두고 저장매체에 기록하는 것 

- UNDO : 기록한 내용을 취소함
- REDO : 트랜잭션 내용을 다시 실행함 

> - NO-UNDO/REDO : 비동기적
> - UNDO/NO-REDO : 동기적
> - UNDO/REDO : 동기/비동기적
> - NO-UNDO/NO-REDO : 동기적으로 저장매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우(동기지만 다른 영역에 저장했기 때문에)

#### 4. 백업 종류 
- 물리 백업 : 데이터베이스 파일을 백업하는 방법. 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어렵다.
- 논리 백업 : DB내의 논리적 객체들을 백업하는 방법. 문제 발생 시 원인 파악 및 해결이 수원하지만 백업/복원 시 시간이 많이 소요된다. 

> - 물리백업 : 로그파일 백업 실시 - 완전복구
> - 물리백업 : 로그파일 백업 없음 - 백업 시점까지 복구
> - 논리백업 : DBMS 유틸리티 - 백업 시점까지 복구

### 👏 098 스토리지 
- 스토리지 : 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술 
- 종류 : DAS, NAS, SAN

#### 1. DAS(Direct Attached Strage) 단어뜻 연상해서 암기
- 서버에서 저장장치를 관리한다. 
- 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉽다. 
- 초기 구축 비용 및 유지보수 비용이 저렴
- 직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일을 공유할 수 없다.
- 확장성 및 유연성이 상대적으로 떨어짐
- 저장 데이터가 적고 공유가 필요 없는 환경에 적합 

#### 2. NAS(Network Attached Strage)
- 서버와 저장장치를 네트워크를 통해 연결하는 방식
- 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리한다.
- Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능하고, 장소에 구애받지 않고 저장장치에 쉽게 접근할 수 있다.
- DAS에 비해 확장성 및 유연성이 우수
- 접속 증가 시 성능 저하

#### 3. SAN(Storage Area Network)
- **파이버 채널** 스위치를 이용해 네트워크를 구성
- 광케이블로 연결하므로 처리 속도가 빠르다. 
- 서버들이 저장장치 및 파일을 공유할 수 있다. 
- 확장성, 유연성, 가용성이 뛰어나다
- 비용이 많이 든다. 

### 👏 099 논리 데이터 모델의 물리 데이터 모델 변환 
#### 1. 테이블 
- 테이블의 구성요소 
  - 로우 
  - 컬럼
  - 기본키 : 기본키는 후보키 중 선택한 주키이다. 특정 튜플을 유일하게 구별할 수 있는 속성
  - 외래키 

#### 2. 엔티티를 테이블로 변환
- 변환시 고려사항
  - 일반적으로 테이블과 엔티티 명칭을 동일하게 하는 것을 권고한다.
  - 엔티티는 주로 한글명을 사용하지만 테이블은 소스 코드의 가독성을 위해 영문명을 사용 
  - 메타 데이터 관리 시스템에 표준화된 용어가 있을 때는 메타에 등록된 단어를 사용하여 명명

#### 3. 슈퍼타입/서브타입을 테이블로 변환

슈퍼타입/서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 한다. 

- **슈퍼타입 기준** 테이블 변환 
  - 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것이다. 
  - 장점
    - 데이터의 액세스가 상대적으로 용이
    - 조인하지 않아도 돼서 수행속도가 빨라짐
    - SQL 문장 구성이 단순해짐

  - 단점 
    - 디스크 저장 공간이 증가
    - 처리마다 서브타입에 대한 구분이 필요한 경우가 많이 발생
    - 인덱스 크기 증가로 인덱스 효율이 떨어짐

- **서브타입 기준** 테이블 변환 
  - 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것 
  - 장점
    - 각 서브타입 속성들의 선택 사양이 명확한 경우에 유리
    - 서브타입 유형을 구분할 필요가 없다.
    - 여러 개의 테이블로 통합하므로 테이블 당 크기가 감소하여 전체 테이블 스캔 시 유리함

  - 단점
    - 수행 속도가 감소
    - 복잡한 처리를 하는 SQL 통합이 어려움
    - 부분 범위에 대한 처리가 곤란해짐
    - 여러 테이블을 통합한 뷰는 조회만 가능
    - UID(식별자, Unique)의 유지 관리가 어려움

- **개별타입 기준** 테이블 변환
  - 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환
  - 장점
    - 저장공간이 상대적으로 작다.
    - 슈퍼타입 또는 서브타입 각각의 테이블에 속한 정보만 조회하는 경우 문장 작성이 용이

  - 단점
    - 슈퍼타입 또는 서브타입의 정보를 같이 처리하면 항상 조인이 발생하여 성능이 저하됨

#### 4. 속성을 컬럼으로 변환

- 일반 속성 변환
  - 개발자와 사용자 간 의사소통을 위해 가능한 한 표준화된 약어를 사용하여 일치시키는 것이 좋다. 
  - 컬럼명은 SQL의 예약어 사용을 피한다.
  - 컬럼명은 SQL가독성을 위해 가능한 한 짧게 지정한다.
  - 복합 단어를 컬럼명으로 사용할 때는 미리 정의된 표준을 따른다. 
  - 테이블의 컬럼을 정의한 후에는 한 로우에 해당하는 샘플 데이터를 작성하여 컬럼의 정합성을 검증한다. 

- Primary UID(주식별자)를 기본키로 변환
  - 논리 데이터 모델에서의 Primary UID는 물리 데이터 모델의 기본키로 만든다.

- Primary UID(관계의 UID Bar : 다른 엔티티와의 관계로 인해 생성된 식별자)를 기본키로 변환
  - 다른 엔티티와의 관계로 인해 생성된 Primary UID는 물리 데이터 모델의 기본키로 만든다. 

- Secondary UID를 유니크키로 변환
  - 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크키로 만든다.

#### 5. 관계를 외래키로 변환 
- 1:1 관계 : 개채 A의 기본키를 개체 B의 외래키로 추가하거나 개체 B의 기본키를 개체A의 외래키로 추가하여 표현한다.(어느쪽이던 상관 없다.)
- 1:M 관계 : 개체 A의 기본키를 개체 B의 외래키로 추가하여 표현하거나 별도의 테이블로 표현한다. 
- N:M 관계 : 릴레이션 A와 B의 기본키를 모두 포함한 별도의 릴레이션으로 표현한다. 이때 생성된 별도의 릴레이션을 교차 릴레이션 이라고 한다. 
- 1:M 순환관계 : 개체 A에 개체 A의 기본키를 참조하는 외래키 컬럼을 추가하여 표현한다. 


#### 6. 관리 목적의 테이블/컬럼 추가
- 논리 데이터 모델에는 존재하지 않는 테이블이나 컬럼을 데이터베이스의 수행 속도를 향상시키기 위해 물리 데이터 모델에 추가할 수 있다. 

#### 7. 데이터 타입 선택
- CHAR : 고정길이 문자열
- VARCHAR2 : 가변길이 문자열
- NUMBER : 숫자
- DATE :  날짜 저장 


### 👏 100 물리 데이터 모델 품질 검토 
#### 1. 물리 데이터 모델 품질 검토 

- 물리 데이터 모델을 설계하고, 데이터베이스 객체를 생성한 후 개발 단계로 넘어가기 전에 모델러와 이해관계자들이 모여 수행한다. 

#### 2. 물리 데이터 모델 품질 기준 (정일완 / 최준활)
- 정확성
- 완전성
- 준거성
- 최신성
- 일관성
- 활용성

#### 3. 물리 데이터 모델의 품질 검토 순서
1. 기준을 **확인**
2. 품질 특성에 따라 품질 **기준을 작성**
3. **체크리스트** 작성
4. 논리 모델과 데이터 모델 **비교**
5. 이해관계자가 **품질 검토를 수행**
6. 품질 검토 **보고서 작성**

## 📚 3장 : SQL 응용
### 👏 101 SQL의 개념

#### 1. SQL의 개요
- IBM 연구에서 개발
- 국제 표준 데이터베이스 언어, 관계형 데이터베이스를 지원하는 언어로 채택하고 있다.
- 관계대수와 관계해석을 기초로 한 혼합 데이터 언어
- 질의어지만 질의 기능 뿐 아니라 데이터 구조의 정의, 데이터 조작, 데이터 제어 기능 모두 가짐

#### 2. SQL의 분류
1.  DDL(Data Define Language, 데이터 정의어)
  - DDL은 SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용
  - 데이터 구조의 사상을 정의한다. 
  - 데이터베이스 관리자나 설계자가 사용한다. 

- DDL의 세 가지 유형 (CAD)
  - CREATE
  - ALTER
  - DROP

2. DML(Date Manipulation Language, 데이터 조작어)
- DML은 데이터를 실질적으로 처리하는 데 사용되는 언어
- 데이터베이스 사용자와 관리 시스템 간의 인터페이스를 제공한다.
- DML의 네 가지 유형(SIDU)
  - SELECT
  - INSERT
  - DELETE
  - UPDATE

3. DCL(Data Control Language, 데이터 제어어)
- DCL은 데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는 데 사용
- DCL의 종류 (CRGR)
  - COMMIT : 명령에 의해 수행된 결과를 실제 물리 디스크에 저장
  - ROLLBACK : 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구
  - GRANT : 권한 부여
  - REVOKE : 권한 취소




### 👏 102 DDL
- DDL : DM를 구축하거나 수정할 목적으로 사용하는 언어


#### 1. CREATE SCHEMA
- 스키마를 정의하는 명령문
- 스키마의 식별을 위해 스키마 이름과 소유권자나 허가권자를 정의한다.

#### 2. CREATE DOMAIN
- 도메인을 정의하는 명령문
- 데이터 타입 : SQL에서 지원하는 데이터 타입
- 기본값 : 데이터를 입력하지 않았을 때 자동으로 입력되는 값

#### 3. CREATE TABLE 
- FOREIGN KEY ~ REFERENCES ~
  - ON DELETE 옵션 : 삭제 되었을 때 기본 테이블에 취해야 할 사항을 지정한다. 
  - ON UPDATE 옵션 : 변경 되었을 때 기본 테이블에 취해야 할 사항을 지정한다. 

> - NO ACTION : 참조 테이블에 변화가 있어도 기본테이블에는 아무런 조치를 취하지 않는다.
> - CASCADE : 참조 테이블의 튜플이 삭제되면 기본 테이블의 관련 튜플들도 모두 삭제되고, 속성이 변경되면 관련 튜플의 속성 값도 모두 변경된다.
> - SET NULL : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성 값을 NULL로 변경
> - SET DEFAULT : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플의 속성값을 기본값으로 변경 


#### 4. CREATE VIEW
- 뷰(SQL 간소화, 보안 목적)를 정의하는 명령문 

#### 5. CREATE INDEX
- 인덱스(검색속도 향상 목적)를 정의하는 명령문 
- UNIQUE
  - 사용된 경우 : 중복 값이 없는 속성으로 인덱스를 생성
  - 생략된 경우 : 중복 값을 허용하는 속성으로 인덱스를 생성

- 정렬 여부 지정(A오D내)
  - ASC : 오름차순
  - DESC : 내림차순
- CLUSTER : 사용하면 인덱스가 클러스터드 인덱스로 설정됨 

#### 6. ALTER TABLE 
- 테이블에 대한 정의를 변경하는 명령문 
- ADD : 새로운 속성을 추가
- ALTER : 값을 변경할 때 사용
- DROP COLUMN :  삭제할 때 사용

#### 7. DROP
- 제거하는 명령문 
- CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거
- RESTRICTED : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소 



### 👏 103 DCL
#### 1. DCL (Data Cotrol Language)
- DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어
-CDL에는 GRANT, REVOE, COMMIT, ROLLBACK, SAVEPOINT 등이 있다.

#### 2. GRANT/REVOKE
- 권한을 부여하거나 취소하가 위한 명령어
- 사용자등급
  - DBA : 데이터베이스 관리자
  - RESOURCE : 테이블 생성 가능자
  - CONNECT : 단순 사용자

- 권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE, ALTER
- WITH GRANT OPTION : 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여함
- GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소함
- CASCADE : 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소함

#### 3. COMMIT
- 변경된 모든 내용을 데이터베이스에 반영해야 하는데, 이때 사용하는 명령이 COMMIT이다.
- COMMIT 명령을 실행하지 않아도 DML문이 성공적으로 완료되면 자동으로 COMMIT되고,DML이 실패하면 자동으로 ROLLBACK이 되도록 Auto Commit 기능을 설정할 수 있다.

#### 4. ROLLBACK
- ROLLBACK 은 아직 COMMIT 되지 않은 변경된 모든 내용을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어다.
- 트랜잭션 전체가 성공적으로 끝나지 못하면 일부 변경된 내용만 데이터베이스에 반영되는 비일관성인 상태를 가질 수 있기 때문에 일부분만 완료된 트랜잭션은 롤백되어야 한다.

#### 5. SAVEPOINT
- 트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정하는 명령어다.

### 👏 104 DML
#### 1. DML(Data Manipulation Language)
- DML은 데이터베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어다.
- SELECT, INSERT, DELETE, UPDATE

#### 2. 삽입문(INSERT INTO)
- 새로운 튜플을 삽입할 때 사용
- INSERT INTO / VALUES

#### 3. 삭제문(DELETE FROM)

#### 4. 갱신문(UPDATE ~ SET)



### 👏 105 DML – SELECT-1
#### 1.  일반형식
> SELECT
> FROM
> WHERE
> ORDER BY

- SELECT 절
  - PREDICATE : 불러올 튜플 수를 제한할 명령어를 기술한다.
    - ALL :  모든 튜플을 검색할 때 지정하는 것으로 주로 생략한다.
    - DISTINCT : 중복된 튜플이 있으면 그중 첫 번째 한 개만 검색한다.
    - DISTINCTROW : 중복된 튜플을 제거하고 한 개만 검색하지만 선택된 속성의 값이 아닌, 튜플 전체를 대상으로 한다.
- FROM 절 : 검색될 데이터를 포함하는 테이블명 기술
- WHERE 절 : 검색할 조건
- ORDER BY 절 : 정렬 (asc : 오름차순 / desc : 내림차순 )

#### 2. 연산자
- like 연산자
  - (%) : 모든 문자를 대표함
  - (-): 문자 하나를 대표함
  - (#): 숫자 하나를 대표함

- 연산자 우선순위
  - 논리연산자 : NOT > AND > OR
  - 산술, 관계 논리 연산자가 함께 사용되었을 때는 산술 > 관계 > 논리 연산자 순서로 우선순위



#### 3. 기본검색
- 한 번만 출력 : DISTINCT

#### 4. 조건 지정 검색

- WHERE 
- WHERE AND
- WHERE OR 
- WHERE LIKE 
- WHERE BETWEEN
- WHERE IS NULL

#### 5. 정렬 검색
- ORDER BY ASC/DESC

#### 6. 하위 질의
- 조건절에 주어진 질의를 먼저 수행하여 그 검색결과를 조건절의 피연산자로 사용한다. 
> - 취미가 나이트댄스인 사원의 이름과 주소를 검색하시오
> SELECT 이름, 주소
> FROM 사원
> WHERE 이름(SELECT 이름 FROM 여가활동 WHERE 취미 = '나이트댄스');
- WHERE NOT IN : 포함되지 않는 데이터를 의미

#### 7. 복수 테이블 검색(조인)
- 여러 테이블을 대상으로 검색을 수행 
> WHERE 
> AND a = b


### 👏 106 DML – SELECT-2

#### 1. 일반 형식
> SELECT [PREDICATE : ALL, DISTINCT] [테이블명]
> [그룹함수]
> [WINDOW함수]
> FROM
> WHERE
> GROUP BY
> HAVING
> ORDER BY


- 그룹함수
  -  COUNT
  -  SUM
  -  AVG
  -  MAX
  -  MIN
  -  STDDEV : 표준편차
  -  VARIANCE : 분산을 구함
  -  ROLLUP : 그룹별 소계를 구하는 함수
  -  CUBE : 인수로 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구한다.

- WINDOW 함수
  - ROW_NUMBER() : 각 레코드에 대한 일련 번호를 반환
  - RANK() : 순위를 반환하며, 공동 순위를 반영
  - DENSE_RANK() : 공동 순위를 무시하고 순위를 부여 

#### 2. WINDOW 함수 이용 검색

- 일련 번호를 구하시오 : ROW_NUMBER()
- 순위를 구하시오 : RANK()

#### 3. 집합연산자를 통한 통합 질의
- 두 개의 SELECT문에 기술한 속성들은 개수와 데이터 유형이 서로 동일해야 한다. 

> - UNION : 통합하여 모두 출력(중복된 행은 한 번만 출력) - 합집합
> - UNION ALL : 통합하여 모두 출력(중복된 행도 그대로 출력) - 합집합
> - INTERSECT : 공통퇸 행만 출력 - 교집합
> - EXCEPT : 첫 번째 셀렉문의 조회결과에서 두 번째 셀렉문의 조회결과를 제외한 행을 출력 - 차집합 

> SELECT * 
> FROM 사원
> **UNION**
> SELECT *
> FROM 직원

### 👏 107 DML -Join
#### 1. JOIN의 개념
- 조인은 2개의 테이블에 대해 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환한다.
- JOIN은 크게 INNER JOIN 과 OUTER JOIN으로 구분된다.

#### 2. INNER JOIN
1. EQUI JOIN
   - EQUI JOIN은 비교에 의해  같은 값을 가지는 행을 연결하여 결과를 생성하는 JOIN 방법이다.
   - EQUI JOIN에서 JOIN 조건이 = 일 때 동일한 속성이 두 번 나타나게 되는데, 이중 중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법을 NATURAL JOIN이라고 한다.
- WHERE절을 이용한 EQUI JOIN
> WHERE 테이블명1.속성명 = 테이블명2.속성명
- NATURAL JOIN을 이용한 EQUI JOIN
>FROM 테이블명1 NATURAL JOIN 테이블명2
- JOIN~USING
>FROM 테이블명1 JOIN 테이블명2 USING(속성명)

2. NON-EQUI JOIN
- NON-EQUI JOIN은 JOIN 조건에 = 조건이 아닌 나머지 비교 연산자, 즉 <,>, <>, >=,<= 연산자를 사용하는 JOIN 방법이다.

#### 3. OUTER JOIN
-  OUTER JOIN은 릴레이션에서 JOIN조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN방법
1. LEFT OUTER JOIN
- ON
>SELECT 테이블명1.속성명, 테이블명2.속성명
>FROM 테이블명1 LEFT OUTER JOIN 테이블명2
>ON 테이블명1.속성명 = 테이블명2.속성명 ;
- (+)
>SELECT 테이블명1.속성명, 테이블명2.속성명
>FROM 테이블명1, 테이블명2
>WHERE 테이블명1.속성명 = 테이블명2.속성명(+) ; – 반대쪽에(+) .. 헷갈리니 주의

2. RIGHT OUTER JOIN
- ON
>SELECT 테이블명1.속성명, 테이블명2.속성명
>FROM 테이블명1 RIGHT OUTER JOIN 테이블명2
>ON 테이블명1.속성명 = 테이블명2.속성명 ;
- (+)
>SELECT 테이블명1.속성명, 테이블명2.속성명
>FROM 테이블명1, 테이블명2
>WHERE 테이블명1.속성명(+) = 테이블명2.속성명; – 반대쪽에(+)

3. FULL OUTER JOIN
- LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐놓은 것이다.
- 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 JOIN의 결과에 추가한다.
>SELECT 테이블명1.속성명, 테이블명2.속성명
>FROM 테이블명1 FULL OUTER JOIN 테이블명2
>ON 테이블명1.속성명 = 테이블명2.속성명 ;


4. SELF JOIN
- SELF JOIN은 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 JOIN 방법이다.
- ON
>SELECT 별칭1.속성명, 별칭1.속성명
>FROM 테이블명1 as 별칭1 JOIN 테이블명1 as 별칭2
>ON 별칭1.속성명 = 별칭2.속성명 ;
- WHERE
>SELECT 별칭1.속성명, 별칭1.속성명
>FROM 테이블명1 as 별칭1,  테이블명1 as 별칭2
>WHERE 별칭1.속성명 = 별칭2.속성명 ;


### 👏 108 프로시저(Procedure)

#### 1. 프로시저
- 프로시저란 절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업을 수행한다.
- 구성도 
> DECLARE
> BEGIN
>   - CONTROL
>   - SQL
>   - EXCEPTION
>   - TRANSACTION
> 
> END 
- DECLARE : 선언부
- BEGIN/AND 
- CONTROL : 조건문 또는 반복문 삽입
- SQL : DML, DCL이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행
- EXCEPTION : BEGIN ~ END 안에 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의
- TRANSACTION : 수행된 데이터 작업들을 DB에 적용할지 취소할지를 결정하는 처리부

#### 2. 프로시저 생성
- 표기형식
> CREATE OR REPLACE PROCEDURE 프로시저명(파라미터)
> BEGIN
> -  프로시저 BODY
> 
> END
- OR REPLACE : 선택적인 예약어. 이 예약어를 사용하면 동일한 프로시저 이름이 이미 존재하는 경우, 기존의 프로시저를 대체할 수 있다.
- 프로시저명
- 파라미터
  - IN : 프로시저에게 값을 전달할 때 지정한다.
  - OUT : 프로그램에게 값을 반환할 때 지정한다. 
  - INOUT : 값을 전달하고, 값을 반환도 한다. 
  - 매개변수명 : 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정 
  - 자료형 : 변수의 자료형을 지정한다. 

- 프로시저 BODY 
  - BEGIN에서 시작하여 END로 끝나며, BEGIN과 END 사이에는 적어도 하나의 SQL문 있어야됨

#### 3. 프로시저 실행
> EXECUTE 프로시저명
> EXEC 프로시저명
> CALL 프로시저명


#### 4. 프로시저 제거 
> DROP PROCEDURE 프로시저명 


### 👏 109 트리거(TRIGGER)

#### 1. 트리거의 개요
- 트리거는 데이터베이스 시스템에서 데이터의 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다. 
- **트리거의 구문에는 DCL을 사용할 수 없다.** (중요)

#### 2. 트리거의 구성
- 트리거 구성도

> 이벤트
> DECLARE
> EVENT
> BEGIN
> - CONTROL
> - SQL
> - EXCEPTION
>
> END
> 데이터 변경

#### 3. 트리거의 생성
- 표기형식
> CREATE OR REPLACE TRIGGER 트리거명 동작시기 동작 ON 테이블명
> REFFERENCING NEW|OLD AS 테이블명
> FOR EACH NOW [WHEN 조건식]
> BEGIN
>   - 트리거 BODY
>
> END

1. 동작시기 : 트리거가 실행될 때를 지정한다.
  - AFTER : 테이블이 변경된 후에 트리거가 실행된다. 
  - BEFORE : 테이블이 변경되기 전에 트리거가 실행된다.

2. 동작 : 트리거가 실행되게 할 작업의 종류를 지정한다. 
  - INSERT
  - DELETE
  - UPDATE

3. NEW|OLD
  - NEW : 추가되거나 수정에 참여할 튜플들의 집합
  - OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합 

4. FOR EACH ROW : 각 튜플마다 트리거를 적용한다는 의미
5. WHEN 조건식 : 트리거를 적용할 튜플의 조건을 지정
6. 트리거 BODY : BEGIN ~ END, 적오도 하나 이상의 SQL문 있어야 한다.

> CREATE TRIGGER 학년정보_tri BEFORE INSERT ON 학생
> REFFRENCING NEW AS new_table 
> FOR EACH ROW
> WHEN(new_table.학년 IS NULL)
> BEGIN
> :new_table.학년:='신입생';
> END

#### 4. 트리거의 제거
> DROP TRIGGER 트리거명;

### 👏 110 사용자 정의 함수

#### 1. 사용자 정의함수의 개요
- 사용자 정의 함수는 데이터베이스에 저장되어 SELECT, INSERT, DELETE, UPDATE 등 DML문의 호출에 의해 실행된다.
- **RETURN 값을 통해 반환하기 때문에 출력 파라미터가 없다.** 중요
- **INSERT, DELETE, UPDATE를 통한 테이블 조작은 할 수 없고 SELECT를 통한 조회만 할 수 있다.**
- 사용자 정의 함수는 프로시저를 호출하여 사용할 수 없다. 
- 사용자 정의 함수는 SUM(), AVG() 등의 내장 함수처럼 DML문에서 반환값을 활용하기 위한 용도로 사용된다. 

#### 2. 프로시저 VS 사용자 정의 함수 
```SQL
구분                             프로시저                       사용자 정의 함수
반환값                      없거나 1개이상 가능                        1개 
파라미터                        입출력 가능                        입력만 가능
사용가능 명령어                  DML,DCL                              SELECT
호출                      프로시저, 사용자 정의 함수             사용자 정의 함수
사용방법                    실행문(EXC, EXCUTE)                     DML에 포함
```


#### 3. 사용자 정의 함수의 구성
- 구성도 

> 데이터
> DECLARE
> BEGIN
> - CONTROL
> - SQL
> - EXCEPTION
> - RETURN
>
> END
> 반환 

- CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리된다.
- SQL : SELECT문이 삽입되어 데이터 조회 작업을 수행
- EXCEPTION : 예외가 발생하면 이를 처리하는 방법을 정의
- RETURN : 반환할 값이나 변수를 정의한다. 


#### 4. 사용자 정의 함수 생성 
- 표기형식
> CREATE OR REPLACE FUNCTION 사용자 정의 함수명(파라미터)
> BEGIN
>   - 사용자 정의 함수 BODY;
>   - RETURN 반환값;
>
> END ; 

- 파라미터  
  - IN : 호출 프로그램이 사용자 정의 함수에게 값을 전달할 때 지정한다.
  - 매개변수명 
  - 자료형

- 사용자 정의 함수 BODY
- RETURN 반환값 
> CREATE FUNCTION GET_S_성별(i_성별코드 IN INT) 
> RETURN VARCHAR2 

#### 5. 사용자 정의 함수 실행
- 표기형식

> SELECT 사용자 정의 함수명 FROM 테이블명
> INSERT INTO 테이블명 VALUES(사용자 정의 함수명);
> DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명 ; 
> UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명 ;

> SELECT 이름.GET_S_성별(성별코드) FROM 사원;

#### 6. 사용자 정의 함수 제거 
> DROP FUNCTION 사용자 정의 함수 ;


### 👏 111 DBMS 접속 기술 

#### 1. DBMS 접속이란?
- DBMS 접속은 사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것을 의미한다.
- 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할을 수행한다.

```SQL 
          매개변수              SQL실행
           -->                   --> 
사용자            응용 시스템               DBMS
          <--                    <--    
        결과전달 
```

#### 2. 웹 응용 시스템의 구조 

```SQL
사용자   <---->    웹서버   <---->    WAS    <---->     DBMS
```
- 사용자는 웹 서버뎅 접속하여 데이터를 주고 받는다
- 웹 서버는 사용자가 대용량의 데이터를 요청하면 직접 처리하지 않고 WAS에게 해당 요청을 전달한다. 
- WAS는 수신한 요청을 DMBS에 전달하여 데이터를 받는다. 이렇게 받은 데이터는 처음 요청한 웹 서버로 다시 전달되어 사용자에게까지 도달하게 된다. 


#### 3. DBMS 접속 기술
- DBMS 접속 기술은 DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크 등을 의미한다.

1. JDBC(Java Database Connectivity)
   - JDBC는 JAVA 언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 때 사용되는 표준 API이다.
   - JDBC는 Java SE에 포함되어 있으며, JDBC클래스는 java, sql, java.sql에 포함되어있다.

2. ODBC(Open DataBase Connectivity)
   - 표준 개방향 API
   - 프로그램 내 ODBC문장을 사용하여 MS-Access, DBase 등 다양한 데이터베이스에 접근 가능 
   -  

3. MyBatis
     - JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈 소스 접속 프레임워크다.
     - SQL 친화적인 국내 환경에 적합하여 많이 사용된다. 

#### 4. 동적 SQL
- 동적 SQL은 사용자로부터 SQL문의 일부 또는 전부를 입력 받아 실행할 수 있다.
- 동적 SQL은 값이 입력되지 않을 경우 사용하는 NVL 함수를 사용할 필요가 없다.
- 동적 SQL은 응용 프로그램 수행시 SQL이 변형될 수 있으므로 프리컴파일 할 때 구문 분석, 접근 권한 확인 등을 할 수 없다. 
- 동적 SQL은 정적 SQL에 비해 속도가 느리지만 유연한 개발이 가능하다.


#### 5. 정적SQL VS 동적SQL

```SQL
                       정적SQL                               동적SQL
SQL 구성         커서를 통한 정적처리                문자열 변수에 담아 동적 처리
개발 패턴     커서의 범위 안에서 SQL 작성          NVL 함수 없이 로직을 통해 SQL 작성 
실행 속도             빠름                                      느림
사전 검사             가능                                      불가능
```


### 👏 112 SQL 테스트 

#### 1. SQL 테스트의 개요
- SQL 테스트 : SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정
- 단문 SQL은 SQL코드를 직접 실행한 후 결과를 확인하는 것으로 간단히 테스트가 가능
- 절차형 SQL은 테스트 전에 생성을 통해 구문오류나 참조 오류의 존재 여부를 확인한다. 


#### 2. 단문 SQL 테스트 
- DESCRIBE, DESC : 개체의 정보를 확인할 때 사용하는 명령어
- ORACLE : SELECT * FROM DBA_ROLE_PRIVES WHERE GRANTEE = 사용자;
- MySQL : SHOW GRANTS FOR 사용자@호스트

#### 3. 절차형 SQL 테스트 
- 절차형 SQL의 특성상 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 오류 내용을 확인하고 문제를 수정한다.
  - 형식 : SHOW ERRORS;

- ORACLE 출력 형식 
  - DBMS_OUTPUT.ENABLE
  - DBMS_OUTPUT_LINE

- MySQL 출력 형식
  - SELECT 데이터


### 👏 113 ORM(Object-Relational-Mapping)

#### 1. ORM 
- 객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술을 의미

#### 2. ORM 프레임워크
- JPA, Hibernate, ODB, Django, DatabaseObjects, NHbiernate, Doctrine

#### 3. ORM의 한계
- 의도대로 SQL이 작성되었는지 확인할 필요가 있다. 
- 객체지향적인 사용을 고려하고 설계된 데이터베이스가 아닌 경우 프로젝트가 크고 복잡해질수록 ORM 기술을 적용하기 어려워진다.
- 기존의 기업들은 ORM을 고려하지 않은 데이터베이스를 사용하기 때문에 ORM에 적합하게 변환하려면 많은 시간과 노력이 필요하다. 

### 👏 114 쿼리 성능 최적화 
- 쿼리 성능 최적화는 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL코드를 최적화 하는 것이다. 

#### 1. RBO VS CBO (중요)
- RMO(Rule Based) : 규칙기반 옵티마이저
- CBO(Cost Based) : 비용기반 옵티마이저

```sql
                               RBO                                 CBO
최적화 기준       규칙에 정의된 우선순위                    액세스 비용
성능 기준         개발자의 SQL 숙련도                       옵티마이저의 예측 성능
특징              실행 계획 예측이 쉬움                     성능 통계치 정보 활용, 예측이복잡함
고려사항          개발자의 규칙 이해도, 규칙의 효율성       비용 산출 공식의 정확성
```

#### 2. 실행 계획
- 실행 계획은 DBMS의 옵티마이저가 수립한 SQL코드의 실행 절차와 방법을 의미한다. 
- 실행 계획은 EXPLAIN 명령어를 통해 확인할 수 있으며, 그래픽이나 텍스트로 표현된다.
- 실행 계획에는 요구사항들을 처리하기 위한 연산 순서가 적혀있으며, 연산에는 조인, 테이블 검색, 필터, 정렬 등이 있다. 


#### 3. 쿼리 성능 최적화 
- SQL 코드 재구성
  - WHERE절을 추가하여 일부 레코드만 조회하게 하여 조회에 들어가는 비용을 줄인다.
  - WHERE절에 연산자가 포함되면 INDEX를 활용하지 못하므로 연산자 사용을 자제한다. 
  - 서브쿼리에 특정 데이터가 존재하는지 확인할 때는 IN보다 EXISTS를 활용한다.(IN은 모든 데이터를 확인하는 반면 EXISTS는 데이터를 찾는 즉시 종료한다.)
  - 옵티마이저의 실행 계획이 잘못되었다고 판단되면 힌트를 활용하여 액세스 경로 및 조인 순서를 변경한다. 
- 인덱스 재구성 
  - SQL 코드에서 조회되는 속성과 조건들을 고려하여 인덱스를 구성
  - 실행 계획을 참고하여 인덱스를 추가하거나 기존 인덱스의 열 순서를 변경
  - 인덱스의 추가 및 변경은 다른 SQL문에도 영향을 줄 수 있으니 신중히 결정한다.
  - 단일 인덱스로 쓰거나 수정 없이 읽기로만 사용되는 테이블의 경우 IOT(Index Orgnizde Table)로 구성하는 것을 고려한다.
  - 불필요한 인덱스를 제거한다. 

 

