## 📚 4회 1과목

### 1. XP(eXtreme Programming)의 기본원리(PT WC DS)

**(1) Pair Programming(짝 프로그래밍)**	
다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경

**(2) Test-Driven Development(테스트 주도 개발)**
개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지 정확히 파악 
테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 사용   

**(3) Whole Team(전체 팀)**
개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 책임을 가져야 함

**(4) Continuous Integration(계속적인 통합)**	
모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 떄마다 지속적으로 통합

**(5) Desgin Improvement(디자인 개선)**
프로그램 기능의 변경 없이, 단순화, 유연성 강화 등을 통해 시스템을 재구성

**(6) Small Releases(소규모 릴리즈)**	
릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응

### 2. 럼바우 객체지향 분석
- 객체 모델링 : 객체 다이어그램
- 동적 모델링 : 상태 다이어그램
- 기능 모델링 : 자료 흐름도

### 3. CASE 주요 기능
- 그래픽 지원
- 소프트웨어 생명주기(Software Lifecycle) 전 단계의 연결
- 다양한 소프트웨어 개발 모형 지원

### 4. 객체지향 설계원칙

#### 객체지향 설계 원칙(SOLID)

**(1) 단일 책임의 원칙(Single Responsibility Principle)**	
하나의 클래스는 하나의 목적을 위해 생성

**(2) 개방 폐쇄 원칙(Open Close Principle)**	
소프트웨어의 구성요소는 확장에는 여려있고, 변경에는 닫혀있어야 한다는 원칙

**(3) 리스코프 치환의 원칙(Liskov Subsitution)**	
서브 타입(상속받은 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙

**(4) 인터페이스 분리의 원칙(Interface Segregation Principle)**	
한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙

**(5) 의존성 역전의 원칙(Dependency Inversion Principle)**	
실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙

### 5 . 아키텍처 패턴

- 아키텍처 패턴의 장점 : 시행착오 출임, 예측 가능, 안정적 개발
- 아키텍처 패턴의 종류 : 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴

**(1) 레이어 패턴(Layers pattern)**
- 시스템 계층으로 구분해 구성하는 고전적인 방법
- 각각의 서브시스템들이 계층 구조를 이룸
- ex) OSI 참조 모델

**(2) 클라이언트-서버 패턴(Client-Sever Pattern)**
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
- 아키텍처 패턴 : 독립적인 업무 또는 기능을 수행하는 실행코드 기반으로 작성된 모듈
- 서버는 클라이언트의 요청에 대비해 항상 대기 상태 유지
- 클라이언트와 서버는 요청과 응답의 경우를 제외한 서로 독립적

**(3) 파이프-필터 패턴(Pipe-Filter Pattern)**
- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
- 재사용성 좋음, 추가가 쉬워 확장 용이
- 필터 컴포넌트 재배치 가능
- 변환, 버퍼링, 동기화 등에 주로 사용
- ex) UNIX의 쉘(Shell)

**(4) 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)**
- 서브시스템을 3개의 부분으로 구조화하는 패턴
  - 모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관
  - 뷰(View) : 사용자에게 정보 표시
  - 컨트롤러(Controller) : 사용자로부터 받은 입력 처리
- 각 부분은 별도의 컴포넌트로 분리되어 있음, 영향 X
- 대화형 애플리케이션에 적합

**(5) 기타 패턴**
- 마스터-슬레이브 패턴 : 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업 분할 후, 슬레이브에게 처리된 결과물을 다시 돌려받음
- 브로커 패턴 : 사용자가 원하는 서비스와 특성을 요청하면 요청에 맞는 컴포넌트와 사용자를 연결해 줌
- 피어-투-피어 패턴 : 피어=하나의 컴포넌트, 각 피어는 클라이언트가 될 수도 서버가 될 수도 있는 패턴, 멀티스레딩 방식
- 이벤트-버스 패턴 : 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리함
- 블랙보드 패턴 : 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾음
- 인터프리터 패턴 : 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성

### 6. 디자인 패턴

**(1) 생성 패턴(Creational Pattern)**

1. 추상 팩토리(Abstract Factory) 
2. 빌더(Builder) 
3. 팩토리 메소드(Factory Method) 
4. 프로토타입(Prototype) 
5. 싱글톤(Singleton) 
 

**(2) 구조 패턴(Structural Pattern)**

1. 어댑터(Adaptor)
2. 브리지(Bridge) 
3. 컴포지트(Composite)
4. 데코레이터(Decorator)
5. 퍼싸드(Facade) 
6. 플라이웨이트(Flyweight) 
7. 프록시(Proxy) 
 

**(3) 행위 패턴(Behavioral Pattern)**

1. 책임 연쇄(Chain of Responsibility)
2. 커맨드(Command) 
3. 인터프리터(Interpreter) 
4. 반복자(Iterator) 
5. 중재자(Mediator)
6. 메멘토(Memento) 
7. 옵서버(Observer) 
8. 상태(State) 
9. 전략(Strategy) 
10. 템플릿 메소드(Template Method)
11. 방문자(Visitor) 


### 7. 디자인 패턴 사용의 장٠단점
- 소프트웨어 구조 파악이 용이하다.
- 객체지향 설계 및 구현의 생산성을 높이는데 적합하다.
- 재사용을 위한 개발 시간이 단축된다.
- 객체지향 언어와 함께 이용될 때 효율이 극대화된다.

### 8. DFD(data flow diagram)
- DFD란?
•	구조적 분석 기법에 이용된다
•	자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화된다
•	자료 흐름 그래프 또는 버블(Bubble)차트라고도 한다

<img src = "https://jtrimind.github.io/assets/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2020-08-07-dfd.png" width="600px">

- DFD의 구성요소
•	process : 원
•	data flow: 화살표
•	data store: 직선(단선/이중선)
•	terminator: 사각형

### 9. UML 기본 구성요소
- 사물(Things)
- 관계(Relationships)
- 다이어그램(Diagram)


### 10. 소프트웨어 상위설계
- 소프트웨어 설계는 요구분석 명세서와 설계 원리
- 제약 조건에 따라 상위 설계와 하위 설계로 나뉠 때 상위에 설계에 해당되는 것
•	사용자 인터페이스 설계
•	아키텍처 설계
•	하위 설계


### 11. 응집도 
기능은 순차적으로 통신해야, 절차적 시간이 논리적이 되고 우연이 낮음

<img src = "https://hyeonukdev.github.io/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0509_02.png" width="650px">

### 12. 요구사항 명세기법
- 비정형 명세기법은 자연어 기반으로 서술
- 정형 명세기법은 수학적인 원리와 표기법을 이용
- 정형 명세기법은 비정형 명세기법에 비해 표현이 간결함


## 📚 4회 2과목 
### 1. EAI
- 모듈 연계는 내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터 교환을 위해 관계를 설정하는 것으로 대표적인 모듈 연계 방법에는 EAI와 ESB 방식이 있다.
- EAI(Enterprise Application Integration)
- EAI는 기업 내 각종 애플리케이션 및 플롯폼 간의 정보 전달, 연계 통합 등 상호 연동이 가능하게 해주는 솔루션이다.
- EAI는 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성을 높여준다.
 
#### 유형기능
- Point-to-Point : 가장 기본적인 애플리케이션 통합 방식으로, 1대1로 연결한다.
- Hub & Spoke
  - 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식.
  - 확장, 유지 보수가 유리하다.
  - 허브 장애 발생시 시스템 전체에 영향이 있다는 단점.
- Message Bus
  - 애플리케이션 사이에 미들웨어를 두어 처리하는 방식이다.
  - 확장성이 뛰어나며 대용량 처리가 가능하다.
- Hybrid Hub & Spoke와 Message Bus의 혼합 방식이다.
  - 그룹 내에서는 Hub & Spoke를, 그룹 간에는 Message Bus방식을사용한다.
  - 필요한 경우 한 가지 방식으로 EAI 구현이 가능하다.
  - 데이터 병목 현상을 최소화 할 수 있다.
 
### 2. ESB(Enterprise Service Bus)
- ESB는 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션이다.
- ESB는 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향한다.
- ESB는 특정 서비스에 국한 되지 않고 범용적으로 사용하기 위해 애플리케이션과의 결합도(Coupling)를 약하게 유지한다.
- 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능하다.
  
EAI의 Hub와 Bus를 잘 기억해주시고, 장단점을 확인하세요! ESB의 특징도 확인!


### 3. 소스코드 품질 분석 도구(종류만 암기)
**(1) 정적 분석 도구** 
● 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구 
● **종류 : pmd, cppcheck, SonarQube, checkstyle, ccm, corvertura** 등

**(2) 동적 분석 도구** 
● 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구
 ● **종류 : Avalanche, Valgrind** 등

### 4. 트리 운행법 

- Root가 앞(Pre)에 있으면 Preorder
- Root가 안(In)에 있으면 Inorder
- Root가 뒤(Post)에 있으면 Postorder

(1)

 <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcrZbTH%2FbtqGtekSsgD%2Fb8Ig2KDKFPiR8cpkTmNRx1%2Fimg.png" width="150px">


 

- Preorder 운행 : Root -> Left -> Right ( A, B, C )
- Inorder 운행 : Left -> Root -> Right ( B, A, C )
- Postorder 운행 : Left -> Right -> Root ( B, C, A )

​
(2)
  <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtkS9s%2FbtqGuspoMRE%2Fj3t8NoVY1LxZIRsX0bYCr1%2Fimg.png" width="300px">


- Preorder 운행 : A B D H I E C F G
- Inorder 운행 : H D I B E A F C G
- Postorder 운행 : H I D E B F G C A

​
(3)
   <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAnEtk%2FbtqGuFWkMTO%2FrMm85SO1g92NkyKLRspYTk%2Fimg.png" width="200px">


 

- Inorder 운행 : D B E A C G F

### 5. 수식의 표기법 
   <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmonIl%2FbtqGxPwU2M7%2FWr97S64sY5GlHVSgCF0Nk1%2Fimg.png" width="150px">

- 전위 표기법(PreFix) : 연산자 -> Left -> Right ( +AB )
- 중위 표기법(InFix) : Left -> 연산자 -> Right ( A+B )
- 후위 표기법(PostFix) : Left -> Right -> 연산자 ( AB+ )

Infix - 연산자가 안에
Prefix - 연산자가 앞에
Postfix - 연산자가 뒤에

​



* 2020년 1, 2회 통합 정보처리기사 필기 기출문제

예) 다음 트리의 전위 순회(Preorder Traversal)한 결과는?

<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbdAblM%2FbtqGtCse9B6%2FspUoqEo5VHIiKxtDH4uwRk%2Fimg.png" width="300px">


 

Preorder : Root -> Left -> Right

+**/ABCDE

### 6. 네트워크 영역에서의 보안
● IPSec : 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉기능을 제공한는 프로토콜
● SSL : TCP/IP계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜
● S-HTTP : 클라이언트와 서버 간에 전송되는 모든 메시지를 암호화하는 프로토콜

오답 : SMTP란? 타인에게 메일을 보낼 때 그 메일은 SMTP로 일단 전송되며 이 SMTP 서버에서 프로그램을 구동하여 해당 메일 주소로 이메일을 보냄


### 7. 정렬
- 선택정렬 - 최저값을 선택해서 첫번재 자리부터 비교하여 자리 교체.
- 버블정렬 - 첫번째 자리부터 비교해가면서 큰 수를 뒤로 보냄.
- 삽입정렬 - 앞의 수들 모두와 비교해가면서 삽입.

9,3,8,2,7 을 오름차순 정렬할때.

 

**(1) 선택정렬**
- 최저값을 선택 -> 2
- 2를 첫번째자리와 비교 9>2 자리 교체

PASS1 -> 2,3,8,9,7 (첫번째 자리 정렬 끝)

- 2 다음 최저값을 선택 -> 3

- 3을 두번째자리와 비교 3=3

PASS2 -> 2,3,8,9.,7 (두번째 자리 정렬 끝)

- 3다음 최저값을 선택 -> 7

- 7을 세번째자리와 비교 8>7 자리교체

PASS3 -> 2,3,7,9,8 

 

9,3,8,2,7 을 오름차순 정렬할때.

**(2) 버블정렬**
- 첫번째 자리부터 선택하여, 비교해가며 큰수를 뒤로 보냄...버블버블 뒤로뒤로..
- 9,3이랑 비교? 9>3 9를 뒤로..버블버블..
- 9,8이랑 비교? 9>8 9를 뒤로..버블버블..
- (생략)

PASS1 -> 3,8,2,7,9 (마지막자리 정렬 끝)

- 3,8 비교? 3>8 8을 뒤로..버블버블

- 8,2 비교? 8>2 8을 뒤로..버블버블..

- (생략)

PASS2 -> 3,2,7,8,9

- 2,3비교? 2>3 3을 뒤로..버블버블

- 3,7비교? 7을 뒤로..버블버블

- (생략)

PASS3 -> 2,3,7,8,9

 

9,3,8,2,7 을 오름차순 정렬할때.

**(3) 삽입정렬**

- 두번째자리인 3과 앞의 수들 비교.. 9>3 3을 첫번째 자리로 삽입

PASS1 -> 3,9,8,2,7

- 세번째자리인 8부터 앞자리 수들 비교 3,9,8> 8은 3보다 크고 9보다 작으므로, 그 사이로 삽입.

PASS2 ->  3,8,9,2,7

- 네번째자리부터 앞자리 수들 비교 3,8,9,2 > 2는 제일 작으므로 첫번째 자리로 삽입

PASS3 -> 2,3,8,9,7


### 8. 인터페이스 구현 검증 도구

- xUnit 
- STAF 
- FitNesse 
- NTAF 
- Selenium 
- watir 

### 9. 스키마


**(1) 외부 스키마(External Schema)**

- 사용자의 관점에서 보여주는 데이터베이스 구조로 전체 데이터베이스의 일부이므로 서브 스키마로고도 함

**(2) 내부 스키마(Internal Schema)**

- 저장장치의 입장에서 데이터베이스 전체가 저장되는 방법을 명세한 것으로 단 하나만 존재함

**(3) 개념 스키마(Conceptual Schema)**

- 전체 사용자 또는 모든 응용 시스템이 필요한 데이터베이스 구조로 조직 전체의 데이터베이스로 단 하나만 존재함



### 10. 빌드 자동화 도구

- 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Complie) 등의 작업들을 수행하는 소프트웨어

**(1) Ant(Another Neat Tool)**

- 아파치 소프트웨어 재단에서 개발한 소프트웨어

- 자바 프로젝트의 공식적인 빌드 자동화 도구

- XML 기반의 빌드 스크립트를 사용

- 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의

- 스크립트의 재사용이 어려움

**(2) Maven**

- 아파치 소프트웨어 재단에서 Ant의 대안으로 개발

- 규칙이나 표준이 존재해 예외 사항만 기록됨

- 컴파일과 빌드를 동시에 수행할 수 있음

- 의존성(Dependency)을 설정하여 라이브러리를 관리

**(3) Gradle**

- 기존의 Ant와 Maven을 보완해 개발된 빌드 자동화 도구

- 안드로이드 스튜디오(안드로이드 앱 개발)의 공식 빌드 도구

- Maven과 동일하게 의존성(Dependency) 활용

- 그루비(Groovy) 기반의 빌드 스크립트 사용

- 플러그인을 설정하면, JAVA, C/C++, Python 등의 언어도 빌드 가능

- 실행할 처리 명령들을 모아 태스크(Task)로 만든 후 태스크 단위로 실행

- 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능 지원 → 빌드의 속도 향상

**(4) Jenkins**

- JAVA 기반의 오픈 소스 형태로 가장 많이 사용되는 빌드 자동화 도구

- 서블릿 컨테이너에서 실행되는 서버 기반 도구

- SVN, Git 등 대부분의 형상 관리 도구와 연동 가능

- 친숙한 Web GUI 제공

- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

### 11.해싱함수 

**(1) 폴딩법**
- 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식

**(2) 제산법**
- 레코드키로 해시표의 크기보다 큰 수 중에서 가장 작은소수로 나눈 나머지를 홈 주소로 삼는 방식

**(3) 기수변환법**
- 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수를 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법

**(4)숫자분석법**
- 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식


## 📚 4회 3과목

### 1.  관계대수 
관계형 데이터베이스에서 원하는 정보과 그 정보를 검색하기 위해서 기술하는 **절차적 언어**
관계대수에는 순수 관계 연산자와 수학적 집합 이론에서 사용되는 일반 집합 연산자가 존재 

● 순수 관계 연산자 : Select, Project, Join, Division
● 일반 집합 연산자 : UNION, INTERSECTION, DIFFERENCE, CARTESIAN PRODUCT

 ### 2. 로킹

● 병행제어에서 한꺼번에 로킹할 수 있는 단위
● 데이터베이스, 파일, 레코드, 필드 등은 로킹단위가 될 수 있음
● 로킹단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아지고, 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡하지만 병행성 수준이 높아짐
● 로킹 단위가 작아지면 데이터베이스 공유도가 증가한다. 
● 로킹 단위가 작아지면 로킹 오버헤드가 증가한다. 

### 3. 뷰

● 저장장치 내에 **물리적으로 존재하지 않지만**, 사용자에게 있는 것 처럼 간주됨
● 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
● 조인문의 사용 최소화로 사용성의 편의성을 최대화

특징
● 기본 테이블과 같은 형대의 구조를 사용하며, 조작도 기본 테이블과 거의 같음
● 데이터의 **논리적 독립성** 제공
● 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
● 뷰에 나타나지 않는 데이터를 안전하게 보호할 수 있음
● 뷰에 대한 조작에서 **삽입, 갱신, 삭제 연산은 제약**이 따른다.(기본키를 포함한 속성 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 가능)
● 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음
● 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제
● 뷰는 **ALTER 사용 금지** 

### 4. 데이터 모델에 표시할 요소(구연제)

- 구조(Structure): 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현

- 연산(Operation): 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구

- 제약 조건(Constraint): DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
오답 : 출력구조 

### 5. 데이터베이스 설계 순서

(1) 요구 조건 분석 : 요구 조건 명세서 작성
(2) 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
(3) 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
(4) 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환(오답 : 스키마 설계)
(5) 구현 : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

### 6. 데이터웨어하우스의 기본적인 OLAP 연산
- roll-up
- dicing
- drill-down

오답 : translate

## 📚 4회 4과목

### 1. 커널의 기능
- 프로세스 생성, 종료
- 기억장치 할당, 회수
- 파일 시스템 관리
- 프로그램과 하드웨어 간 인터페이스(오답 : 사용자 인터페이스)

### 2.  OSI 7 계층

**7계층) Application Layer (응용계층)**

- 사용자의 인터페이스 역할

- 사용자와 가장 가까운 프로토콜 정의

**6계층) Presentation Layer (표현계층)**

- 전송하는 데이터의 Format을 결정

- 다양한 데이터 Format을 일관되게 상호 변환, 압축 및 복호화 기능을 수행

**5계층) Session Layer (세션 계층)**

- 네트워크 상에서 통신을 할 경우 양쪽 host간 최초 연결이 되게하고 통신 중 연결이 지속되도록 해주는 계층

- 통신하는 두 host사이에서 세션을 열고, 닫고, 관리

- 데이터 동기화와 네트워크 오류 이벤트 검사, 오류 발생 지점 이후의 데이터만 재전송 보장

- 데이터의 송수신 방식, 반 이중 방식, 전 이중 방식의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정을 수행

**4계층) Transport Layer (전송 계층)**

- 정보를 분할 하고, 상대평에 도달하기 전에 다시 합치는 과정을 담당

- 에러제어와 흐름제어를 담당

- 전송방식 결정

**3계층) Network Layer (네트워크 계층)**

- 로컬 주소를 담당하고, 패킷의 이동 경로를 결정

- 경로선택, 라우팅, 논리적인 주소 정의

- 라우팅 프로토콜을 이용해 최적의 경로 선택

**2계층) Data Link Layer (데이터링크 계층)**

- 물리적 계층을 통한 데이터 전송에 신뢰성 제공

- 직접 연결되어있지 않은 네트워크에 대해서는 상위 계층에서 오류 제어를 담당

**1계층) Physical Layer (물리계층)**

- 네트워크 통신을 위한 물리적인 표준을 정의

- 두 컴퓨터 간의 전기적, 기계적, 절차적인 연결을 정의하는 계층

### 3. 쉘스크립트
다음 중 bash 쉘 스크립트에서 사용할 수 있는 제어문이 아닌 것은?
  1) if
  2) for
  3) repeat_do
  4) while


● 변수, 선택적 실행문(if문, case문), 반복문(for문, while문, until문, select문), 루프제어문(continue문)

### 4. 파이썬
다음 파이썬으로 구현된 프로그램의 실행 결과로 옳은 것은?

<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuIPzm%2FbtqJOyGcGB5%2FXdahaC2eYKFvnuS7KGdnN1%2Fimg.png" width="1000px">

① [20, 60]
② [60, 20]
③ [0, 20, 40, 60]
④ [10, 30, 50, 70]


① a[2::4]
② a[6::-4]
③ a[:7:2]
④ a[1:8:2]

**정리: a[시작인덱스:종료인덱스:step]**

### 5. 공통모듈 재사용 
- 함수와 객체 재사용 
- 컴포넌트 재사용 
- 애플리케이션 재사용 

오답 : 더미코드 재사용

 ### 6. 결합도
 ● **data coupling(자료 결합도)** : 모듈 간의 인터페이스가 자료 요소로만 구성될 떄의 결합도

● **stamp coupling(스탬프 결합도)** : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달 될 때의 결합도

● **control coupling(제어 결합도)** : 어떤 모듈이 다른 모듈의 내부의 논리적 흐름을 제어하기 위해 제어신호를 이용하여 통신하더나 제어요소를 전달하는 결합도

● **External coupling(외부 결합도)** : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도 

● **common coupling(공통 결합도)** : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도

● **content coupling(내용 결합도)** : 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정할 때의 결합도 

### 7. 응집도

● **기능적 응집도** : 모듈 내부의 모든 기능 요소들이 **단일 문제**와 연관되어 수행될 경우의 응집도

● **순차적 응집도** : 하나의 활동으로 부터 나온 출력 데이터를 **그 다음 활동의 입력으로 사용**할 경우의 응집도

● **교환(통신)적 응집도** : **동일한 입력과 출력을 사용하여 서로 다른 기능을 수행**하는 구성 요소들이 모였을 경우

● **절차적 응집도** : 모듈이 다수 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 **순차적**으로 수행할 경우의 응집도

● **시간적 응집도** : **특정 시간**에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도

● **논리적 응집도** : **유사한 성격**을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

### 8. TCP와 UDP 차이점
**(1) TCP**
데이터 전송 전 연결설정
**1:1 전송**
단계별 데이터 전송
**신뢰성**있는 데이터 전송

**(2) UDP**
데이터 전송 전 연결 미설정
**1:다 전송**
데이터 전송
**비 신뢰성** 데이터 전송

### 9. TCP/IP에서 논리주소를 물리주소로 변환시켜주는 프로토콜 
**= ARP**

### 10. PHP 연산자
@ : 함수 사용시 발생되는 오류메시지를 표시하지 않음

<> : 값이 서로 같지 않을 때 (!=)

= : 값을 지정할 때 사용

== : 두 값이 같은지 확인하기

=== : 두 값이 같고, 형식도 같은지 확인하기 (좀 더 깐깐)

:: : new 지시자로 class를 미리 객체화 시켜놓지 않고, 사용하는 시점에서 객체가 생성되고 지정된 method가 실행되도록 하는 접근자

## 📚 4회 5과목 

### 1. CMM
**초반정관최** 

### 2. SOA(Service Oriented Architecture, 서비스 지향 아키텍처) 계층

- 표현 계층(Presentation Layer)

- 프로세스 계층(Process Layer)

- 서비스 계층(Service Layer)

- 비즈니스 계층(Business Layer)

- 영속 계층(Persistency Layer)


### 3. 정보의 접근통제 정책
정책

MAC : 시스템 / 보안등급(Label) / 고정적(변경 어려움) / 안정적 중앙 집중적

DAC : 데이터 소유자 / 신분(Identity) / 변경 용이 / 구현 용이 유연함






### 4. 암호 알고리즘 
- 암호 알고리즘 : 패스워드, 주민번호, 은행계좌와 같은 중요정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 의미함 
- 단방향 암호화 방식 : 해시 사용
- 양방향 암호화 방식 : 개인키 및 공개키 사용 

```SQL
                                          Stream 방식
                            개인키-------
              양방향-------               Block 방식
                            공개키 
암호화 방식---
    
              단방향-------  HASH
```

#### (1) 개인키 암호화 기법
- 동일한 키로 데이터를 암호화하고 복호화 한다. 
- 사용자는 평문의 정보 M을 암호화 알고리즘 E와 개인키 K를 이용하여 암호화 C로 바꾸어 저장시켜 놓으면 사용자는 복호화 알고리즘 D와 개인키 K를 이용하여 다시 평문의 정보 M으로 바꾸어 이용하는 방법이다. 
- 개인키 암호화 기법은 대칭 암호 기법 또는 단일키 암호화 기법이라고도 한다.
- 종류 
  - 블록 암호화 방식(DES, SEED, AES, ARIA)
  - 스크림 암호화 방식(LFSR, RC4)


- 장점 : 암호화 / 복호화 속도 빠르며, 알고리즘 단순, 공개키 암호 기법보다 크기 작음 
- 단점 : 사용자 증가에 따라 관리해야 할 키의 수가 상대적으로 많아짐

#### (2) 공개키 암호화
- 데이터를 암호화할 때 사용하는 공개키는 데이터베이스 사용자에게 공개하고, 복호화할 때의 비밀키 관리자가 비밀리에 관리한다. 
- 사용자는 평문의 정보 M을 암호화 알고리즘 E와 공개키 P를 이요하여 암호문 C로 바꾸어 저장시켜 놓고, 이를 복호화하기 위해서는 비밀키와 복호화 알고리즘에 권한이 있는 사용자만이 복호화 알고리즘 D와 비밀키 S를 이용해 다시 평문의 정보 M으로 바꿀 수 있는 기법이다. 

- 비대칭 암호기법이라고도 하며, 대표적으로 RSA기법이 있다.
- 장점 : 키의 분배 용이, 관리해야 할 키의 개수가 적다
- 단점 : 암호화 / 복호화 속도가 느리며, 알고리즘이 복잡, 파일의 크기가 크다.

> - 공개키 기반 구조
>   - X.509방식 : 인증기관에서 발생하는 인증서를 기반으로 상호 인증을 제공
>   - 비X.509방식 : 국가별, 지역별로 맞게 보완 및 개발

> **양방향 알고리즘 종류**
> - 개인키 
>   - SEED : 블록크키 = 128, 키 길이 = 128, 256
>   - ARIA : 블록크기 = 128, 키 길이 = 128, 192, 256
>   - DES : 블록크기 = 64, 키 길이 = 56
>   - AES : 블록크기 = 128, 키 길이 = 128, 192, 256
> - 공개키
>   - RSA : 공개키와 비밀키 사용


### 5. SDDC(Software-Defined Data Center, 소프트웨어 정의 데이터센터)

데이터센터를 효율적으로 운영하고 편하게 관리하기 위해 등장한 모든 컴퓨팅 인프라를 가상화하여 서비스하는 데이터센터

- 소프트웨어 정의 컴퓨팅(SDC), 소프트웨어 정의 네트워킹(SDN), 소프트웨어 정의 스토리지(SDS), 소프트웨어 정의 시설관리(SDF) 기술이 활용된다.

- 인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다.

- 특정 하드웨어와 상관없이 독립적이다.

- 실제 물리적 환경과 동일하게 구성된다.

- 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의해 데이터센터를 구성·관리한다.


### 6. N-S Chart(Nassi-Shneiderman Chart)

순서도와는 달리 논리기술에 중점을 두고 상자도형을 이용한 도형식 설계도구로 순차(연속), 선택, 반복, 다중선택(Case, 케이스) 제어 구조를 표현하는 도구
