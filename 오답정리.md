## 📚 3회 1과목
### 1. CASE(Computer-Aided Software Engineering)

**(1) CASE란?**
- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용의 소프트웨어 도구를 사용하여 자동화
- 표준화된 개발 환경 구축 및 문서 자동화 기능을 제공
- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대
- 이점
  - 개발을 신속하게 할 수 있다.
  - 오류 수정이 쉬워 S/W 품질이 향상된다.
  - S/W개발 단계의 표준화를 기할 수 있다.
- CASE 분류
    - 상위 CASE
      - 모델들 사이의 모순검사 가능
      - 모델의 오류검증 기능
      - 자료흐름도 작성 기능
    - CASE 도구의 정보저장소(Repository)
      - 일반적으로 정보저장소는 도구들과 생명주기 활동, 사용자들, 응용 소프트웨어들 사이의 통신과 소프트웨어 시스템 정보의 공유를 향상시킨다.
      - 초기의 소프트웨어 개발 환경에서는 사람이 정보저장소 역할을 했지만 오늘날에는 응용 프로그램이 정보저장소 역할을 담당한다.
      - 소프트웨어 시스템 구성 요소들과 시스템 정보가 정보저장소에 의해 관리되므로 소프트웨어 시스템의 유지보수가 용이해진다.
  
**(2) CASE의 주요 기능**
  - 그래픽 지원
  - 소프트웨어 생명주기(Software Lifecycle) 전 단계의 연결
  - 다양한 소프트웨어 개발 모형 지원



### 2. 시퀀스 다이어그램(Squence Diagram)

- 어떠한 순서로 어떤 객체들과 어떻게 상호작용을 했는지 표현하는 다이어그램
- 세부요소

    - 생명선 : 모델링 되는 개개의 인스턴스를 나타냄

    - 실행 : 인스턴스가 실제로 다른 인스턴스와 상호작용을 하며 활성화되어있는 것을 나타냄

  -   메시지 : 인스턴스간의 주고받는 데이터


### 3. 디자인패턴

(1) 생성 패턴 (Creational Pattern)

● Factory Method 패턴 

- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴

- 상위 클래스에서 인터페이스만 정의하고 실제 생성을 서브 클래스가 담당

 

(2) 구조 패턴 (Structural Pattern)

● Bridge 패턴

- 구현부에서 추상층을 분리하여, 서로 독립적으로 확장 가능하게 구성한 패턴

- 기능과 구련을 두 개의 별도 클래스로 구현

 

(3) 행위 패턴 (Behavioral Pattern)

● Visitor 패턴

- 각 클래스들이 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴

- 분리된 처리 기능은 각 클래스를 방문visit 하여 수행

 

● Observer 패턴

- 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴

- 주로 분산된 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야할 때 이용

### 4. 미들웨어
미들웨어(Middleware)

운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적으로 서비스를 제공하는 소프트 웨어

● DB(DataBase) : 데이터베이스 벤더에서 제공하는 크라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어

● RPC(Romote Procedure Call) : 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미둘웨어

● MOM(Message Oriented Middleware) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어

● TP-Monitor(Trasaction Processing Monitor) : 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어

● ORB(Object Request Broker) :객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 수현하는 미들웨어

● WAS(Web Application Server) : 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 위해 사용되는 미들웨어


![screensh](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOIdVs%2FbtqG7SIfYxJ%2FuqIk96IprxjgAbclc6Wzg1%2Fimg.jpg
)

### 5. UML 다이어그램 종류

**구조적(Structural) 다이어그램**	
- 클래스(Class) 다이어그램
- 객체(Object) 다이어그램
- 컴포넌트(Component) 다이어그램
- 배치(Deployment) 다이어그램
- 복합체 구조(Composite) 다이어그램
- 패키지(Package) 다이어그램	

**행위(Behavioral) 다이어그램**
- 유스케이스(Use Case) 다이어그램
- 시퀀스(Sequence) 다이어그램
- 커뮤니케이션(Communucation) 다이어그램
- 상태(State) 다이어그램
- 활동(Activity) 다이어그램
- 상호작용 개요(Interaction Overview) 다이어그램
- 타이밍(Timing) 다이어그램 


### 6. 자료사전 기호

● { } : 자료의 반복

● ** : 자료의 설명(주석)

● = : 자료의 정의

● ( ) : 자료의 생략

● + : 자료의 연결

● [ | ] : 자료의 선택 (A or B) 

### 7. 객체지향 설계 5대 원칙

● SRP (Single Responsibility Principle) : 모든 클래스는 각각 하나의 책임만 가져야함. 클래스는 그 책임을 캡슐화애햐함.

● OCP (Open Closed Principle) : 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야함.

● LSP (Liskow Substitution Principle) : 자식 클래스는 언제나 부모 클래스를 대체가능 할 수 있어야함.

● ISP (Interface Segregation Principle) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야함. 

● DIP (Dependendy Inversion Principle) : 변화하기 쉬운 것 보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존해야함.

### 8. 자료 흐름도 구성요소

● process : 자료를 변환 시키는 시스템의 한 부분. (=처리, 기능, 변환, 버블) / 원

● data flow : 자료의 이동을 나타냄 / 화살표

● data store : 시스템에서의 자료 저장소 / 삼각형

● terminator : 시스템과 교신하는 외부 객체. 입력 데이터가 만들어지로 출력데이터를 받음 / 사각형

## 📚 3회 2과목

### 1. 인터페이스 보안 - 네트워크 영역

● IPsec : 네트워크 층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜

● SSL : TCP/IP 계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜

● S-HTTP : 클라이언트와 서버 간에 전송되는 모든 메시지를 암호화 하는 프로토콜

 
- 오답 : SMPT : 타인에게 메일을 보낼 때 그 매일은 SMPT로 전송 > SMPT서버에서 프로그램을 구동하여 해당 메일 주소로 이메일을 보냄


### 2. 제어흐름 그래프 McCabe cyclomatic 수 계산 
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FePOJ8Q%2FbtqIXknKtZU%2F6sqY9GD0HQ2Eor47iaCky0%2Fimg.png" width="250px">

<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTmDbs%2FbtqIN984rTa%2Fw60kKQubFizlN8sz3g8Ds1%2Fimg.png" width="150px">

V = E(Edge) - N(Node) + 2

6-4+2 = 4

### 3. 정렬 정리(선택, 버블, 삽입)



### 4. 트리 운행법 
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtO5Jp%2FbtqISrOZfxx%2F0whKCFBiD7zL1TNgOz20zk%2Fimg.png" width="250px">


● 전위 (Preoder) 순회 : 뿌리 먼저 방문, 뿌리 > 왼쪽자식 > 오른쪽 자식

A B A C E G H F

● 중위 (Inorder) 순회 : 왼쪽 하위 트리를 방문 후 뿌리 방문, 왼쪽자식 > 뿌리 > 오른쪽 자식

D B G E H C F C

● 후위 (Postorder) 순회 : 하위 트리를 모두 방문 후 뿌리 방문, 왼쪽 자식 > 오른쪽 자식 > 뿌리

D B G H E F C A

### 5. 알고리즘 설계기법
● 분할정복법(Divide & Conquer)

- 분할이 가능한 부분까지 분할 > 분할된 하위과제들을 모두 해결(정복) > 정복된 해답을 모두 취합

- 대표 : 퀵 정렬 알고리즘, 병렬 정렬 알고리즘

● 동적계획법 (Dynamic Programming) 

- 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용해 나가는 기법

- 이전 단계의 해답을 활용하기 위해 저장소가 필요함에 따라 속도는 빠르지만, 공간복잡도가 커짐

- 대표 : 플로이드 알고리즘, 피보나치 수 알고리즘

● 탐욕법 (Greedy Method)

- 국소적인 관점에서 최적해를 구하는 기법

- 대표 : 크루스칼 알고리즘, 다익스트라 알고리즘

● 퇴각검색법 (Backtracking)

- 어떤 문제의 최적해를 구하기 위해 모든 가능성을 찾아가는 방법, 최적해를 찾으면 더 이상 다른 노드에 방문할 필요가 없음

- 가던 길이 아니면 back 할 수 있음

● 분기한정법 (Branch & Bound)

- 퇴각검색법과 유사함. 임의로 답이 될 것같은 부분을 먼저 탐색한다는 차이를 가지고 있음

- 정해진 범위 bound를 벗어나는 값들을 가지치기 branck 해가며 결과값을 추적해 나감

- 대표 : 최적우선 탐색 알고리즘, A* 알고리즘 

● 근사해법 (Approximation Algorithm)

- 복잡도가 매우 높은 문제에 대한 가장 근사치의 값을 구하는 기법

### 6. 파티션(Patition)
대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
- 종류
● 범위 분할 (Range Partitioning) : 지정한 열의 값을 기준으로 분할
● 해시 분할 (Hash Partitioning) : 해시 함수를 적용한 결과 값에 따라 데이터 분할
● 조합 분할 (Composite Partitioning) : 범위 분할로 분할한 다음 해시 함수를 적용하여 재 분할

### 7. 테스트
테스트 단계 : 단위테스트 > 통합테스트 > 시스템테스트 > 인수테스트

● 단위 테스트

- 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트

- 방법 : 구조 기반 테스트, 명세 기반 테스트

 

● 통합 테스트

- 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트

 

● 시스템 테스트

- 개발된 SW가 해당 컴퓨터 시스템에서 완벽하게 수행되는가

 

● 인수 테스트
- 사용자의 요구사항을 충족하는지에 중점을 둔 테스트
- 종류 : 사용자 인수 테스트, 운영상의 인수 테스트, 계약 인수 테스트, 규정 인수 테스트, 알파 테스트, 베타 테스트


## 📚 3회 3과목

### 1. 정규화 과정

① 비정규 릴레이션

     ▼  도메인이 원자값

② 1NF (제1정규형) : 릴레이션의 모든 속성 값이 원자값으로만 되어있는 정규형

     ▼  부분적 함수 종속 제거

③ 2NF (제2정규형) : 릴레이션 R이 1NF. 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족

     ▼  이행적 함수 종속 제거

④ 3NF (제3정규형) : 릴레이션 R이 2NF. 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않는 정규형 

     ▼  결정자이면서 후보키가 아닌 것 제거

⑤ BCNF (Boyce-Dodd 정규형) : 릴레이션 R에서 결정자가 모두 후보키인 정규형

     ▼  다치 종속 제거

⑥ 4NF (제4정규형) : 릴리이션 R에 A ─▶▶B가 성립하는 경우 R은 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형

     ▼  조인 종속성 이용

⑦ 5NF (제5정규형/, PJ/NF) : 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형

 ### 2. 로킹(Locking)

- 주요 데이터의 엑세스를 상호배타적으로 하는 것

- 트랜잭션들이 어떤 로킹 단위를 엑세스하기 전에 Lock을 요청해서 Lock이 허락되어야 그 로킹단위를 엑세스 할 수 있도록 하는 기법

 

로킹단위

● 로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다. 

● 데이터베이스, 파일, 레코드, 필드 등은 로킹단위가 될 수 있음

● 로킹의 단위가 작아지면 로킹 오버헤드가 증가한다. 

● 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아짐

● 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡하지만 병행성 수준이 높아짐

### 3. 무결성
데이터베이스에 저장된 데이터 값과 그것을 표현하는 현실 세계의 실제 값이 일치하는 정확성

● 개체 무결성 : 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없음

● 도메인 무결성 : 주어진 속성 값이 정의된 도메인에 속한 값이어야한다는 규정

● 참조 무결성 : 외래키값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야함

● 사용자 정의 무결성 : 속성 값들이 사용자가 정의한 제약 조건에 만족 해야함

### 4. 뷰

● 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게 있는 것 처럼 간주됨
● 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
● 조인문의 사용 최소화로 사용성의 편의성을 최대화

장점
● 논리적 데이터 독립성 제공
● 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구 지원
● 사용자의 데이터 관리를 간단하게 함
● 접근 제어를 통한 자동 보안 제공

단점
● 독립적 인덱스를 가질 수 없음
● 정의 변경 불가능
● 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

 ### 5. 분산 데이터 베이스 
논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스

목표
● 위치 투명성 (Location Transparency) : 데이터의 논리적인 명칭만으로 액세스 가능

● 중복 투명성 (Replication Transparency) : 사용자는 하나의 데이터만 존재 하는 것 처럼사용. 시스템은 자동으로 여러 자료에 대한 작업 수행

● 병행 투명성 (Concurrency Transparency) : 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션 결과는 영향 받지 않음

● 장애 투명성 (Failure Transparency) : 여러 장애에도 트랜잭션을 정확히 처리

### 6. 관계대수 
관계형 데이터베이스에서 원하는 정보과 그 정보를 검색하기 위해서 기술하는 절차적 언어

● 순수 관계 연산자 : Select, Project, Join, Division

● 일반 집합 연산자 : UNION, INTERSECTION, DIFFERENCE, CARTESIAN PRODUCT

### 7. anomaly
- anomaly : 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상

### 8. 릴레이션 특징

● 한 릴레이션에는 같은 튜플이 포함될 수 없음. 릴레이션에 포함된 튜플들은 모두 상이함

● 한 릴레이션에 포함된 튜플 사이에는 순가서 없음

● 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변함

● 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음

● 속성의 유일한 식별을 위해 속성의 명칭은 유일해야함.

● 속성을 구성하는 값은 동일한 값이 있을 수 있음.

● 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(key)로 설정

● 속성의 값은 논리적으로 더이상 쪼갤 수 없는 원자값만 저장


## 📚 3회 4과목

### 1. 소프트웨어 취약점 
● FTP 바운스 공격 : FTP 프로토콜 구조의 허점을 이용한 공격 방법

● SQL 삽입 : SQL명령에 사용된 특수 요소의 부적절한 무효화

● 버퍼 오버플로우 (buffer overflow)
- 일종의 메모리 안전 문제
- 프로그램이 할당된 고정 길이 메모리 버퍼의 한계를 제대로 확인하지 않고 보유할 수 있는 것 보다  많은 데이터를 쓰는 경우, 데이터가 인접 메모리 공간으로 넘쳐 그곳의 정보를 덮어쓰게됨
- 충돌이나 악용 가능한 상태 유발

● 디렉토리 접근 공격(directory traversal) : 사용자가 접근이 허가되지 않은 디렉토리로 접근을 할 수 있는 것

### 2. 쉘
쉘(shell) : 운영체제에서 제공하는 명령을 실행하는 프로그램
쉘 스크립트 : 시스템에서 지원하는 명령어들의 집합을 묶어서 프로그램화 한 것

 
쉘의 종류
● Bourne shell
● C shell
● Korn shell
● bach shell

쉘 스크립트 프로그래밍
● C 언어와 유사한 프로그래밍
● LINUX의 많은 부분이 쉘 스크립트로 되어있다
● 변수, 선택적 실행문(if문, case문), 반복문(for문, while문, until문, select문), 루프제어문(continue문)
● 별도로 컴파일 하지 않고 텍스트 파일 형태로 바로 실행 가능

### 3. IPv

IPv6
● 128비트의 주소 사용 (16비트씩 8부분)
● 기밀성, 인증성, 데이터 무결성의 지원으로 보안 문제 해결
● IPv4와 호환성이 뛰어남
● 주소의 확장성, 융통성, 연동성이 뛰어남
● 실시간 흐름제어로 멀티미디어 기능을 제공함
● Traffic Class, Flow Label을 이용하여 등급별, 서비스로 패킷을 구분할 수 있어 품질 보장이 용이하다.
● 자동으로 네트워크 환경구성이 가능 

IPv4
● 32비트 주소체계 사용 (8비트씩 4부분)

### 4. HRN (Highest Response ratio Next) 비선점 스케줄링 

 
```

작업	대기시간	서비스 (실행) 시간
A	    5	                20
B	    40	                20
C	    15	                45
D	    20              	2
```

우선 순위 : (대기시간+서비스시간)/서비스 시간

A : (5+20)/20=1.25
B : (40+20)/20=3
C : (15+45)/45=1.33..
D : (20+20)/2=11

### 5. 배치 프로그램 (Batch Program)
사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것

필수요소

● 대용량 데이터 : 대량의 데이터를 처리

● 자동화 : 심각한 오류 상황 외에 사용자 개입없이 수행되야함

● 견고성 : 잘못된 데이터나 중복 등의 상황으로 중단되는 일 없이 수행

● 안정성/신뢰성 : 오류가 발생하면 추적할 수 있어야함

● 성능 : 다른 응용프로그램 수행을 방해하지 않고, 지정된 시간 내에 처리가 완료되어야 함

### 6. TCP

● 양방향 연결형 서비스 제공

● 가상 회선 연결 형태의 서비스 제공

● 스크림 위주의 전달

● 신뢰성 있는 경로를 확립하고 메시지 전송을 감독

● 순서제어, 오류제어, 흐름제어 기능

● 패킷의 분실, 손상, 지연, 순서 오류 등 발생시 투명성 이보장되는 환경 제공

### 7. 응집도의 종류

● 기능적 응집도 : 모듈 내부의 모든 기능 요소들이 **단일 문제**와 연관되어 수행될 경우의 응집도

● 순차적 응집도 : 하나의 활동으로 부터 나온 출력 데이터를 **그 다음 활동의 입력으로 사용**할 경우의 응집도

● 교환(통신)적 응집도 : **동일한 입력과 출력을 사용하여 서로 다른 기능을 수행**하는 구성 요소들이 모였을 경우

● 절차적 응집도 : 모듈이 다수 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 **순차적**으로 수행할 경우의 응집도

● 시간적 응집도 : **특정 시간**에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도

● 논리적 응집도 : **유사한 성격**을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

### 8. ISO 7 계층

● 하위 계층 : 물리 계층 > 데이터 링크 계층 > 네트워크 계층
● 상위 계층 : 전송 계층 > 세션 계층 > 표현 계층 > 응용 계층

데이터링크 계층 : 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송
● 송, 수신 측의 속도차이 해결을 위한 흐름제어
● 프레임의 동기화 기능
● 오류제어 기능
● 순서제어 기능

### 9.

입력 값 : Hello World
최종 출력 : Helrld

srting[시작 위치:끝 위치] 
string[음수 : ] = 문자열의 뒤쪽부터 역순으로 센 글자

 string[0:3] + string[-3:]


 ### 10. 결합도
 ● data coupling(자료 결합도) : 모듈 간의 인터페이스가 자료 요소로만 구성될 떄의 결합도

● stamp coupling(스탬프 결합도) : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달 될 때의 결합도

● control coupling(제어 결합도) : 어떤 모듈이 다른 모듈의 내부의 논리적 흐름을 제어하기 위해 제어신호를 이용하여 통신하더나 제어요소를 전달하는 결합도

● External coupling(외부 결합도) : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도 

● common coupling(공통 결합도) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도

● content coupling(내용 결합도) : 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정할 때의 결합도 
## 📚 3회 5과목
### 1. FP 모형에서 비용산정에 이용되는 요소 

● 소프트웨어의 기능을 증대시키는 요일별로 가중치 부여. 요인별 가중치를 합산하여 총 기능점수를 산출하면 총 기능 점수와 영향도를 이용해 FP를 구함

기능점수(FP) = 총 기능 점수 x [0.65 + (0.1 x 총 영향도)]

●기능별 가중치 : 
자료 입력(입력 양식) 
정보 출력(출력 보고서)
명령어(사용자 질의수)
데이터 파일
필요한 외부 루틴과의 인터페이스

### 2. 암호 알고리즘 
- 암호 알고리즘 : 패스워드, 주민번호, 은행계좌와 같은 중요정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 의미함 
- 단방향 암호화 방식 : 해시 사용
- 양방향 암호화 방식 : 개인키 및 공개키 사용 

```SQL
                                          Stream 방식
                            개인키-------
              양방향-------               Block 방식
                            공개키 
암호화 방식---
    
              단방향-------  HASH
```

#### (1) 개인키 암호화 기법
- 동일한 키로 데이터를 암호화하고 복호화 한다. 
- 사용자는 평문의 정보 M을 암호화 알고리즘 E와 개인키 K를 이용하여 암호화 C로 바꾸어 저장시켜 놓으면 사용자는 복호화 알고리즘 D와 개인키 K를 이용하여 다시 평문의 정보 M으로 바꾸어 이용하는 방법이다. 
- 개인키 암호화 기법은 대칭 암호 기법 또는 단일키 암호화 기법이라고도 한다.
- 종류 
  - 블록 암호화 방식(DES, SEED, AES, ARIA)
  - 스크림 암호화 방식(LFSR, RC4)


- 장점 : 암호화 / 복호화 속도 빠르며, 알고리즘 단순, 공개키 암호 기법보다 크기 작음 
- 단점 : 사용자 증가에 따라 관리해야 할 키의 수가 상대적으로 많아짐

#### (2) 공개키 암호화
- 데이터를 암호화할 때 사용하는 공개키는 데이터베이스 사용자에게 공개하고, 복호화할 때의 비밀키 관리자가 비밀리에 관리한다. 
- 사용자는 평문의 정보 M을 암호화 알고리즘 E와 공개키 P를 이요하여 암호문 C로 바꾸어 저장시켜 놓고, 이를 복호화하기 위해서는 비밀키와 복호화 알고리즘에 권한이 있는 사용자만이 복호화 알고리즘 D와 비밀키 S를 이용해 다시 평문의 정보 M으로 바꿀 수 있는 기법이다. 

- 비대칭 암호기법이라고도 하며, 대표적으로 RSA기법이 있다.
- 장점 : 키의 분배 용이, 관리해야 할 키의 개수가 적다
- 단점 : 암호화 / 복호화 속도가 느리며, 알고리즘이 복잡, 파일의 크기가 크다.

> - 공개키 기반 구조
>   - X.509방식 : 인증기관에서 발생하는 인증서를 기반으로 상호 인증을 제공
>   - 비X.509방식 : 국가별, 지역별로 맞게 보완 및 개발

> **양방향 알고리즘 종류**
> - 개인키 
>   - SEED : 블록크키 = 128, 키 길이 = 128, 256
>   - ARIA : 블록크기 = 128, 키 길이 = 128, 192, 256
>   - DES : 블록크기 = 64, 키 길이 = 56
>   - AES : 블록크기 = 128, 키 길이 = 128, 192, 256
> - 공개키
>   - RSA : 공개키와 비밀키 사용

### 3. 비용 산정의 자동화 도구

● SLIM : Raleigh-Norden곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구

● ESTIMACS : FP모형을 기초로 하여 개발된 자동화 추정 도구

### 4. 암호 알고리즘

양방향 알고리즘 종류

● SEED : 1999년 / 한국인터넷진흥원(KISA) / 블록 암호화 알고리즘 / 블록 크기 128비트, 키 길이에 따라 128, 256으로 분류됨

● ARIA : 2004년 / 국정원, 산학연합회가 / 블록 암호화 알고리즘 / 블록크기 128비트, 키 길이에 따라 128, 192, 256으로 분류됨

● DES : 1975년 / 미국 NBS / 개인키 암호화 알고리즘 / 블록크기 64비트, 키 길이 56비트

● AES : 2001년 / 미국 표준 기술 연구소(NIST) / 개인키 암호화 알고리즘 / 블록크기 128비트, 키 길이에 따라 128, 192, 256으로 분류됨

● RSA : 1987년 / MIT / 공개키 암호화 알고리즘 / 큰 숫자를 소인수분해하기 어렵다는 것에 기반하여 만들어짐 / 공개키와 비밀키 사용 / 키 = 메시지를 열고 잠그는 상수

### 5. CMP 임계경로
- 가장 오래 걸리는 루트 

### 6. RIP(Routing Information Protocol) 라우팅 프로토콜

● 거리 벡터 (Distance Vector)에 근거한 알고리즘

● Bellman-Ford 거리 벡터 알고리즘에 기초

● 소규모 또는 교육용 등 비교적 간단한 네트워크에 주로 사용

● 최정 결로로 홉 계수를 사용 (도달한 목적까지 몇 개의 라우터를 거치는가)

● 최대 15 홉 수로 제한

### 7. 네트워크 재사용 방법

● 합성 중심 : 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추어 소프트웨어를 완성 (=블록 구성 방법)

● 생성 중심 : 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법 (=패턴 구성 방법)

 